module.exports = {

"[project]/node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/instance.ts
__turbopack_context__.s({
    "isStaging": ()=>isStaging
});
function isStaging(frontendApi) {
    return frontendApi.endsWith(".lclstage.dev") || frontendApi.endsWith(".stgstage.dev") || frontendApi.endsWith(".clerkstage.dev") || frontendApi.endsWith(".accountsstage.dev");
}
;
 //# sourceMappingURL=chunk-3TMSNP4L.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/constants.ts
__turbopack_context__.s({
    "CURRENT_DEV_INSTANCE_SUFFIXES": ()=>CURRENT_DEV_INSTANCE_SUFFIXES,
    "DEV_OR_STAGING_SUFFIXES": ()=>DEV_OR_STAGING_SUFFIXES,
    "LEGACY_DEV_INSTANCE_SUFFIXES": ()=>LEGACY_DEV_INSTANCE_SUFFIXES,
    "LOCAL_API_URL": ()=>LOCAL_API_URL,
    "LOCAL_ENV_SUFFIXES": ()=>LOCAL_ENV_SUFFIXES,
    "PROD_API_URL": ()=>PROD_API_URL,
    "STAGING_API_URL": ()=>STAGING_API_URL,
    "STAGING_ENV_SUFFIXES": ()=>STAGING_ENV_SUFFIXES,
    "iconImageUrl": ()=>iconImageUrl
});
var LEGACY_DEV_INSTANCE_SUFFIXES = [
    ".lcl.dev",
    ".lclstage.dev",
    ".lclclerk.com"
];
var CURRENT_DEV_INSTANCE_SUFFIXES = [
    ".accounts.dev",
    ".accountsstage.dev",
    ".accounts.lclclerk.com"
];
var DEV_OR_STAGING_SUFFIXES = [
    ".lcl.dev",
    ".stg.dev",
    ".lclstage.dev",
    ".stgstage.dev",
    ".dev.lclclerk.com",
    ".stg.lclclerk.com",
    ".accounts.lclclerk.com",
    "accountsstage.dev",
    "accounts.dev"
];
var LOCAL_ENV_SUFFIXES = [
    ".lcl.dev",
    "lclstage.dev",
    ".lclclerk.com",
    ".accounts.lclclerk.com"
];
var STAGING_ENV_SUFFIXES = [
    ".accountsstage.dev"
];
var LOCAL_API_URL = "https://api.lclclerk.com";
var STAGING_API_URL = "https://api.clerkstage.dev";
var PROD_API_URL = "https://api.clerk.com";
function iconImageUrl(id, format = "svg") {
    return `https://img.clerk.com/static/${id}.${format}`;
}
;
 //# sourceMappingURL=chunk-I6MTSTOF.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "addClerkPrefix": ()=>addClerkPrefix,
    "cleanDoubleSlashes": ()=>cleanDoubleSlashes,
    "getClerkJsMajorVersionOrTag": ()=>getClerkJsMajorVersionOrTag,
    "getScriptUrl": ()=>getScriptUrl,
    "hasLeadingSlash": ()=>hasLeadingSlash,
    "hasTrailingSlash": ()=>hasTrailingSlash,
    "isAbsoluteUrl": ()=>isAbsoluteUrl,
    "isCurrentDevAccountPortalOrigin": ()=>isCurrentDevAccountPortalOrigin,
    "isLegacyDevAccountPortalOrigin": ()=>isLegacyDevAccountPortalOrigin,
    "isNonEmptyURL": ()=>isNonEmptyURL,
    "joinURL": ()=>joinURL,
    "parseSearchParams": ()=>parseSearchParams,
    "stripScheme": ()=>stripScheme,
    "withLeadingSlash": ()=>withLeadingSlash,
    "withTrailingSlash": ()=>withTrailingSlash,
    "withoutLeadingSlash": ()=>withoutLeadingSlash,
    "withoutTrailingSlash": ()=>withoutTrailingSlash
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3TMSNP4L$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
;
;
// src/url.ts
function parseSearchParams(queryString = "") {
    if (queryString.startsWith("?")) {
        queryString = queryString.slice(1);
    }
    return new URLSearchParams(queryString);
}
function stripScheme(url = "") {
    return (url || "").replace(/^.+:\/\//, "");
}
function addClerkPrefix(str) {
    if (!str) {
        return "";
    }
    let regex;
    if (str.match(/^(clerk\.)+\w*$/)) {
        regex = /(clerk\.)*(?=clerk\.)/;
    } else if (str.match(/\.clerk.accounts/)) {
        return str;
    } else {
        regex = /^(clerk\.)*/gi;
    }
    const stripped = str.replace(regex, "");
    return `clerk.${stripped}`;
}
var getClerkJsMajorVersionOrTag = (frontendApi, version)=>{
    if (!version && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3TMSNP4L$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isStaging"])(frontendApi)) {
        return "canary";
    }
    if (!version) {
        return "latest";
    }
    return version.split(".")[0] || "latest";
};
var getScriptUrl = (frontendApi, { clerkJSVersion })=>{
    const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\/\//, "");
    const major = getClerkJsMajorVersionOrTag(frontendApi, clerkJSVersion);
    return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;
};
function isLegacyDevAccountPortalOrigin(host) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEGACY_DEV_INSTANCE_SUFFIXES"].some((legacyDevSuffix)=>{
        return host.startsWith("accounts.") && host.endsWith(legacyDevSuffix);
    });
}
function isCurrentDevAccountPortalOrigin(host) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CURRENT_DEV_INSTANCE_SUFFIXES"].some((currentDevSuffix)=>{
        return host.endsWith(currentDevSuffix) && !host.endsWith(".clerk" + currentDevSuffix);
    });
}
var TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
function hasTrailingSlash(input = "", respectQueryAndFragment) {
    if (!respectQueryAndFragment) {
        return input.endsWith("/");
    }
    return TRAILING_SLASH_RE.test(input);
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
    if (!respectQueryAndFragment) {
        return input.endsWith("/") ? input : input + "/";
    }
    if (hasTrailingSlash(input, true)) {
        return input || "/";
    }
    let path = input;
    let fragment = "";
    const fragmentIndex = input.indexOf("#");
    if (fragmentIndex >= 0) {
        path = input.slice(0, fragmentIndex);
        fragment = input.slice(fragmentIndex);
        if (!path) {
            return fragment;
        }
    }
    const [s0, ...s] = path.split("?");
    return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
    if (!respectQueryAndFragment) {
        return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
    }
    if (!hasTrailingSlash(input, true)) {
        return input || "/";
    }
    let path = input;
    let fragment = "";
    const fragmentIndex = input.indexOf("#");
    if (fragmentIndex >= 0) {
        path = input.slice(0, fragmentIndex);
        fragment = input.slice(fragmentIndex);
    }
    const [s0, ...s] = path.split("?");
    return (s0.slice(0, -1) || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function hasLeadingSlash(input = "") {
    return input.startsWith("/");
}
function withoutLeadingSlash(input = "") {
    return (hasLeadingSlash(input) ? input.slice(1) : input) || "/";
}
function withLeadingSlash(input = "") {
    return hasLeadingSlash(input) ? input : "/" + input;
}
function cleanDoubleSlashes(input = "") {
    return input.split("://").map((string_)=>string_.replace(/\/{2,}/g, "/")).join("://");
}
function isNonEmptyURL(url) {
    return url && url !== "/";
}
var JOIN_LEADING_SLASH_RE = /^\.?\//;
function joinURL(base, ...input) {
    let url = base || "";
    for (const segment of input.filter((url2)=>isNonEmptyURL(url2))){
        if (url) {
            const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
            url = withTrailingSlash(url) + _segment;
        } else {
            url = segment;
        }
    }
    return url;
}
var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
var isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
;
 //# sourceMappingURL=chunk-IFTVZ2LQ.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "__export": ()=>__export,
    "__privateAdd": ()=>__privateAdd,
    "__privateGet": ()=>__privateGet,
    "__privateMethod": ()=>__privateMethod,
    "__privateSet": ()=>__privateSet,
    "__reExport": ()=>__reExport
});
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg)=>{
    throw TypeError(msg);
};
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __accessCheck = (obj, member, msg)=>member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter)=>(__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value)=>member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter)=>(__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method)=>(__accessCheck(obj, member, "access private method"), method);
;
 //# sourceMappingURL=chunk-7ELT755Q.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/url.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IFTVZ2LQ$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3TMSNP4L$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
;
;
 //# sourceMappingURL=url.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/url.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IFTVZ2LQ$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3TMSNP4L$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$url$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/url.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-N2V3PKFE.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/retry.ts
__turbopack_context__.s({
    "retry": ()=>retry
});
var defaultOptions = {
    initialDelay: 125,
    maxDelayBetweenRetries: 0,
    factor: 2,
    shouldRetry: (_, iteration)=>iteration < 5,
    retryImmediately: false,
    jitter: true
};
var RETRY_IMMEDIATELY_DELAY = 100;
var sleep = async (ms)=>new Promise((s)=>setTimeout(s, ms));
var applyJitter = (delay, jitter)=>{
    return jitter ? delay * (1 + Math.random()) : delay;
};
var createExponentialDelayAsyncFn = (opts)=>{
    let timesCalled = 0;
    const calculateDelayInMs = ()=>{
        const constant = opts.initialDelay;
        const base = opts.factor;
        let delay = constant * Math.pow(base, timesCalled);
        delay = applyJitter(delay, opts.jitter);
        return Math.min(opts.maxDelayBetweenRetries || delay, delay);
    };
    return async ()=>{
        await sleep(calculateDelayInMs());
        timesCalled++;
    };
};
var retry = async (callback, options = {})=>{
    let iterations = 0;
    const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter } = {
        ...defaultOptions,
        ...options
    };
    const delay = createExponentialDelayAsyncFn({
        initialDelay,
        maxDelayBetweenRetries,
        factor,
        jitter
    });
    while(true){
        try {
            return await callback();
        } catch (e) {
            iterations++;
            if (!shouldRetry(e, iterations)) {
                throw e;
            }
            if (retryImmediately && iterations === 1) {
                await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));
            } else {
                await delay();
            }
        }
    }
};
;
 //# sourceMappingURL=chunk-N2V3PKFE.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/retry.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$N2V3PKFE$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-N2V3PKFE.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=retry.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/retry.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$N2V3PKFE$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-N2V3PKFE.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$retry$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/retry.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/isomorphicAtob.ts
__turbopack_context__.s({
    "isomorphicAtob": ()=>isomorphicAtob
});
var isomorphicAtob = (data)=>{
    if (typeof atob !== "undefined" && typeof atob === "function") {
        return atob(data);
    } else if (("TURBOPACK compile-time value", "object") !== "undefined" && ("TURBOPACK ident replacement", globalThis).Buffer) {
        return new ("TURBOPACK ident replacement", globalThis).Buffer(data, "base64").toString();
    }
    return data;
};
;
 //# sourceMappingURL=chunk-TETGTEI2.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/isomorphicBtoa.ts
__turbopack_context__.s({
    "isomorphicBtoa": ()=>isomorphicBtoa
});
var isomorphicBtoa = (data)=>{
    if (typeof btoa !== "undefined" && typeof btoa === "function") {
        return btoa(data);
    } else if (("TURBOPACK compile-time value", "object") !== "undefined" && ("TURBOPACK ident replacement", globalThis).Buffer) {
        return new ("TURBOPACK ident replacement", globalThis).Buffer(data).toString("base64");
    }
    return data;
};
;
 //# sourceMappingURL=chunk-KOH7GTJO.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "buildPublishableKey": ()=>buildPublishableKey,
    "createDevOrStagingUrlCache": ()=>createDevOrStagingUrlCache,
    "getCookieSuffix": ()=>getCookieSuffix,
    "getSuffixedCookieName": ()=>getSuffixedCookieName,
    "isDevelopmentFromPublishableKey": ()=>isDevelopmentFromPublishableKey,
    "isDevelopmentFromSecretKey": ()=>isDevelopmentFromSecretKey,
    "isProductionFromPublishableKey": ()=>isProductionFromPublishableKey,
    "isProductionFromSecretKey": ()=>isProductionFromSecretKey,
    "isPublishableKey": ()=>isPublishableKey,
    "parsePublishableKey": ()=>parsePublishableKey
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
;
;
;
// src/keys.ts
var PUBLISHABLE_KEY_LIVE_PREFIX = "pk_live_";
var PUBLISHABLE_KEY_TEST_PREFIX = "pk_test_";
var PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\.clerk\.accounts([a-z.]*)(dev|com)$/i;
function buildPublishableKey(frontendApi) {
    const isDevKey = PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) || frontendApi.startsWith("clerk.") && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEGACY_DEV_INSTANCE_SUFFIXES"].some((s)=>frontendApi.endsWith(s));
    const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;
    return `${keyPrefix}${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isomorphicBtoa"])(`${frontendApi}$`)}`;
}
function isValidDecodedPublishableKey(decoded) {
    if (!decoded.endsWith("$")) {
        return false;
    }
    const withoutTrailing = decoded.slice(0, -1);
    if (withoutTrailing.includes("$")) {
        return false;
    }
    return withoutTrailing.includes(".");
}
function parsePublishableKey(key, options = {}) {
    key = key || "";
    if (!key || !isPublishableKey(key)) {
        if (options.fatal && !key) {
            throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
        }
        if (options.fatal && !isPublishableKey(key)) {
            throw new Error("Publishable key not valid.");
        }
        return null;
    }
    const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? "production" : "development";
    let decodedFrontendApi;
    try {
        decodedFrontendApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isomorphicAtob"])(key.split("_")[2]);
    } catch  {
        if (options.fatal) {
            throw new Error("Publishable key not valid: Failed to decode key.");
        }
        return null;
    }
    if (!isValidDecodedPublishableKey(decodedFrontendApi)) {
        if (options.fatal) {
            throw new Error("Publishable key not valid: Decoded key has invalid format.");
        }
        return null;
    }
    let frontendApi = decodedFrontendApi.slice(0, -1);
    if (options.proxyUrl) {
        frontendApi = options.proxyUrl;
    } else if (instanceType !== "development" && options.domain && options.isSatellite) {
        frontendApi = `clerk.${options.domain}`;
    }
    return {
        instanceType,
        frontendApi
    };
}
function isPublishableKey(key = "") {
    try {
        const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);
        if (!hasValidPrefix) {
            return false;
        }
        const parts = key.split("_");
        if (parts.length !== 3) {
            return false;
        }
        const encodedPart = parts[2];
        if (!encodedPart) {
            return false;
        }
        const decoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isomorphicAtob"])(encodedPart);
        return isValidDecodedPublishableKey(decoded);
    } catch  {
        return false;
    }
}
function createDevOrStagingUrlCache() {
    const devOrStagingUrlCache = /* @__PURE__ */ new Map();
    return {
        /**
     * Checks if a URL is a development or staging environment.
     *
     * @param url - The URL to check (string or URL object).
     * @returns `true` if the URL is a development or staging environment, `false` otherwise.
     */ isDevOrStagingUrl: (url)=>{
            if (!url) {
                return false;
            }
            const hostname = typeof url === "string" ? url : url.hostname;
            let res = devOrStagingUrlCache.get(hostname);
            if (res === void 0) {
                res = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DEV_OR_STAGING_SUFFIXES"].some((s)=>hostname.endsWith(s));
                devOrStagingUrlCache.set(hostname, res);
            }
            return res;
        }
    };
}
function isDevelopmentFromPublishableKey(apiKey) {
    return apiKey.startsWith("test_") || apiKey.startsWith("pk_test_");
}
function isProductionFromPublishableKey(apiKey) {
    return apiKey.startsWith("live_") || apiKey.startsWith("pk_live_");
}
function isDevelopmentFromSecretKey(apiKey) {
    return apiKey.startsWith("test_") || apiKey.startsWith("sk_test_");
}
function isProductionFromSecretKey(apiKey) {
    return apiKey.startsWith("live_") || apiKey.startsWith("sk_live_");
}
async function getCookieSuffix(publishableKey, subtle = globalThis.crypto.subtle) {
    const data = new TextEncoder().encode(publishableKey);
    const digest = await subtle.digest("sha-1", data);
    const stringDigest = String.fromCharCode(...new Uint8Array(digest));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isomorphicBtoa"])(stringDigest).replace(/\+/gi, "-").replace(/\//gi, "_").substring(0, 8);
}
var getSuffixedCookieName = (cookieName, cookieSuffix)=>{
    return `${cookieName}_${cookieSuffix}`;
};
;
 //# sourceMappingURL=chunk-IV7BOO4U.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/keys.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
 //# sourceMappingURL=keys.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/keys.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$keys$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/keys.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/runtimeEnvironment.ts
__turbopack_context__.s({
    "isDevelopmentEnvironment": ()=>isDevelopmentEnvironment,
    "isProductionEnvironment": ()=>isProductionEnvironment,
    "isTestEnvironment": ()=>isTestEnvironment
});
var isDevelopmentEnvironment = ()=>{
    try {
        return ("TURBOPACK compile-time value", "development") === "development";
    } catch  {}
    return false;
};
var isTestEnvironment = ()=>{
    try {
        return ("TURBOPACK compile-time value", "development") === "test";
    } catch  {}
    return false;
};
var isProductionEnvironment = ()=>{
    try {
        return ("TURBOPACK compile-time value", "development") === "production";
    } catch  {}
    return false;
};
;
 //# sourceMappingURL=chunk-7HPDNZ3R.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "deprecated": ()=>deprecated,
    "deprecatedObjectProperty": ()=>deprecatedObjectProperty,
    "deprecatedProperty": ()=>deprecatedProperty
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)");
;
// src/deprecated.ts
var displayedWarnings = /* @__PURE__ */ new Set();
var deprecated = (fnName, warning, key)=>{
    const hideWarning = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTestEnvironment"])() || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isProductionEnvironment"])();
    const messageId = key ?? fnName;
    if (displayedWarnings.has(messageId) || hideWarning) {
        return;
    }
    displayedWarnings.add(messageId);
    console.warn(`Clerk - DEPRECATION WARNING: "${fnName}" is deprecated and will be removed in the next major release.
${warning}`);
};
var deprecatedProperty = (cls, propName, warning, isStatic = false)=>{
    const target = isStatic ? cls : cls.prototype;
    let value = target[propName];
    Object.defineProperty(target, propName, {
        get () {
            deprecated(propName, warning, `${cls.name}:${propName}`);
            return value;
        },
        set (v) {
            value = v;
        }
    });
};
var deprecatedObjectProperty = (obj, propName, warning, key)=>{
    let value = obj[propName];
    Object.defineProperty(obj, propName, {
        get () {
            deprecated(propName, warning, key);
            return value;
        },
        set (v) {
            value = v;
        }
    });
};
;
 //# sourceMappingURL=chunk-UEY4AZIP.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/deprecated.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$UEY4AZIP$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
;
 //# sourceMappingURL=deprecated.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/deprecated.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$UEY4AZIP$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$deprecated$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/deprecated.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-35WGBVWP.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/error.ts
__turbopack_context__.s({
    "ClerkAPIResponseError": ()=>ClerkAPIResponseError,
    "ClerkRuntimeError": ()=>ClerkRuntimeError,
    "ClerkWebAuthnError": ()=>ClerkWebAuthnError,
    "EmailLinkError": ()=>EmailLinkError,
    "EmailLinkErrorCode": ()=>EmailLinkErrorCode,
    "EmailLinkErrorCodeStatus": ()=>EmailLinkErrorCodeStatus,
    "buildErrorThrower": ()=>buildErrorThrower,
    "errorToJSON": ()=>errorToJSON,
    "is4xxError": ()=>is4xxError,
    "isCaptchaError": ()=>isCaptchaError,
    "isClerkAPIResponseError": ()=>isClerkAPIResponseError,
    "isClerkRuntimeError": ()=>isClerkRuntimeError,
    "isEmailLinkError": ()=>isEmailLinkError,
    "isKnownError": ()=>isKnownError,
    "isMetamaskError": ()=>isMetamaskError,
    "isNetworkError": ()=>isNetworkError,
    "isPasswordPwnedError": ()=>isPasswordPwnedError,
    "isReverificationCancelledError": ()=>isReverificationCancelledError,
    "isUnauthorizedError": ()=>isUnauthorizedError,
    "isUserLockedError": ()=>isUserLockedError,
    "parseError": ()=>parseError,
    "parseErrors": ()=>parseErrors
});
function isUnauthorizedError(e) {
    const status = e?.status;
    const code = e?.errors?.[0]?.code;
    return code === "authentication_invalid" && status === 401;
}
function isCaptchaError(e) {
    return [
        "captcha_invalid",
        "captcha_not_enabled",
        "captcha_missing_token"
    ].includes(e.errors[0].code);
}
function is4xxError(e) {
    const status = e?.status;
    return !!status && status >= 400 && status < 500;
}
function isNetworkError(e) {
    const message = (`${e.message}${e.name}` || "").toLowerCase().replace(/\s+/g, "");
    return message.includes("networkerror");
}
function isKnownError(error) {
    return isClerkAPIResponseError(error) || isMetamaskError(error) || isClerkRuntimeError(error);
}
function isClerkAPIResponseError(err) {
    return "clerkError" in err;
}
function isClerkRuntimeError(err) {
    return "clerkRuntimeError" in err;
}
function isReverificationCancelledError(err) {
    return isClerkRuntimeError(err) && err.code === "reverification_cancelled";
}
function isMetamaskError(err) {
    return "code" in err && [
        4001,
        32602,
        32603
    ].includes(err.code) && "message" in err;
}
function isUserLockedError(err) {
    return isClerkAPIResponseError(err) && err.errors?.[0]?.code === "user_locked";
}
function isPasswordPwnedError(err) {
    return isClerkAPIResponseError(err) && err.errors?.[0]?.code === "form_password_pwned";
}
function parseErrors(data = []) {
    return data.length > 0 ? data.map(parseError) : [];
}
function parseError(error) {
    return {
        code: error.code,
        message: error.message,
        longMessage: error.long_message,
        meta: {
            paramName: error?.meta?.param_name,
            sessionId: error?.meta?.session_id,
            emailAddresses: error?.meta?.email_addresses,
            identifiers: error?.meta?.identifiers,
            zxcvbn: error?.meta?.zxcvbn,
            plan: error?.meta?.plan,
            isPlanUpgradePossible: error?.meta?.is_plan_upgrade_possible
        }
    };
}
function errorToJSON(error) {
    return {
        code: error?.code || "",
        message: error?.message || "",
        long_message: error?.longMessage,
        meta: {
            param_name: error?.meta?.paramName,
            session_id: error?.meta?.sessionId,
            email_addresses: error?.meta?.emailAddresses,
            identifiers: error?.meta?.identifiers,
            zxcvbn: error?.meta?.zxcvbn,
            plan: error?.meta?.plan,
            is_plan_upgrade_possible: error?.meta?.isPlanUpgradePossible
        }
    };
}
var ClerkAPIResponseError = class _ClerkAPIResponseError extends Error {
    constructor(message, { data, status, clerkTraceId, retryAfter }){
        super(message);
        this.toString = ()=>{
            let message = `[${this.name}]
Message:${this.message}
Status:${this.status}
Serialized errors: ${this.errors.map((e)=>JSON.stringify(e))}`;
            if (this.clerkTraceId) {
                message += `
Clerk Trace ID: ${this.clerkTraceId}`;
            }
            return message;
        };
        Object.setPrototypeOf(this, _ClerkAPIResponseError.prototype);
        this.status = status;
        this.message = message;
        this.clerkTraceId = clerkTraceId;
        this.retryAfter = retryAfter;
        this.clerkError = true;
        this.errors = parseErrors(data);
    }
};
var ClerkRuntimeError = class _ClerkRuntimeError extends Error {
    constructor(message, { code }){
        const prefix = "\u{1F512} Clerk:";
        const regex = new RegExp(prefix.replace(" ", "\\s*"), "i");
        const sanitized = message.replace(regex, "");
        const _message = `${prefix} ${sanitized.trim()}

(code="${code}")
`;
        super(_message);
        /**
     * Returns a string representation of the error.
     *
     * @returns A formatted string with the error name and message.
     */ this.toString = ()=>{
            return `[${this.name}]
Message:${this.message}`;
        };
        Object.setPrototypeOf(this, _ClerkRuntimeError.prototype);
        this.code = code;
        this.message = _message;
        this.clerkRuntimeError = true;
        this.name = "ClerkRuntimeError";
    }
};
var EmailLinkError = class _EmailLinkError extends Error {
    constructor(code){
        super(code);
        this.code = code;
        this.name = "EmailLinkError";
        Object.setPrototypeOf(this, _EmailLinkError.prototype);
    }
};
function isEmailLinkError(err) {
    return err.name === "EmailLinkError";
}
var EmailLinkErrorCode = {
    Expired: "expired",
    Failed: "failed",
    ClientMismatch: "client_mismatch"
};
var EmailLinkErrorCodeStatus = {
    Expired: "expired",
    Failed: "failed",
    ClientMismatch: "client_mismatch"
};
var DefaultMessages = Object.freeze({
    InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
    InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
    MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
    MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
    MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
});
function buildErrorThrower({ packageName, customMessages }) {
    let pkg = packageName;
    function buildMessage(rawMessage, replacements) {
        if (!replacements) {
            return `${pkg}: ${rawMessage}`;
        }
        let msg = rawMessage;
        const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
        for (const match of matches){
            const replacement = (replacements[match[1]] || "").toString();
            msg = msg.replace(`{{${match[1]}}}`, replacement);
        }
        return `${pkg}: ${msg}`;
    }
    const messages = {
        ...DefaultMessages,
        ...customMessages
    };
    return {
        setPackageName ({ packageName: packageName2 }) {
            if (typeof packageName2 === "string") {
                pkg = packageName2;
            }
            return this;
        },
        setMessages ({ customMessages: customMessages2 }) {
            Object.assign(messages, customMessages2 || {});
            return this;
        },
        throwInvalidPublishableKeyError (params) {
            throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
        },
        throwInvalidProxyUrl (params) {
            throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
        },
        throwMissingPublishableKeyError () {
            throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
        },
        throwMissingSecretKeyError () {
            throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));
        },
        throwMissingClerkProviderError (params) {
            throw new Error(buildMessage(messages.MissingClerkProvider, params));
        },
        throw (message) {
            throw new Error(buildMessage(message));
        }
    };
}
var ClerkWebAuthnError = class extends ClerkRuntimeError {
    constructor(message, { code }){
        super(message, {
            code
        });
        this.code = code;
    }
};
;
 //# sourceMappingURL=chunk-35WGBVWP.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/error.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$35WGBVWP$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-35WGBVWP.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=error.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/error.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$35WGBVWP$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-35WGBVWP.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$error$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/error.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/isomorphicAtob.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=isomorphicAtob.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/isomorphicAtob.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$isomorphicAtob$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/isomorphicAtob.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/buildAccountsBaseUrl.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "buildAccountsBaseUrl": ()=>buildAccountsBaseUrl
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
// src/buildAccountsBaseUrl.ts
function buildAccountsBaseUrl(frontendApi) {
    if (!frontendApi) {
        return "";
    }
    const accountsBaseUrl = frontendApi.replace(/clerk\.accountsstage\./, "accountsstage.").replace(/clerk\.accounts\.|clerk\./, "accounts.");
    return `https://${accountsBaseUrl}`;
}
;
 //# sourceMappingURL=buildAccountsBaseUrl.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/authorization.ts
__turbopack_context__.s({
    "createCheckAuthorization": ()=>createCheckAuthorization,
    "resolveAuthState": ()=>resolveAuthState,
    "splitByScope": ()=>splitByScope,
    "validateReverificationConfig": ()=>validateReverificationConfig
});
var TYPES_TO_OBJECTS = {
    strict_mfa: {
        afterMinutes: 10,
        level: "multi_factor"
    },
    strict: {
        afterMinutes: 10,
        level: "second_factor"
    },
    moderate: {
        afterMinutes: 60,
        level: "second_factor"
    },
    lax: {
        afterMinutes: 1440,
        level: "second_factor"
    }
};
var ALLOWED_LEVELS = /* @__PURE__ */ new Set([
    "first_factor",
    "second_factor",
    "multi_factor"
]);
var ALLOWED_TYPES = /* @__PURE__ */ new Set([
    "strict_mfa",
    "strict",
    "moderate",
    "lax"
]);
var isValidMaxAge = (maxAge)=>typeof maxAge === "number" && maxAge > 0;
var isValidLevel = (level)=>ALLOWED_LEVELS.has(level);
var isValidVerificationType = (type)=>ALLOWED_TYPES.has(type);
var prefixWithOrg = (value)=>value.replace(/^(org:)*/, "org:");
var checkOrgAuthorization = (params, options)=>{
    const { orgId, orgRole, orgPermissions } = options;
    if (!params.role && !params.permission) {
        return null;
    }
    if (!orgId || !orgRole || !orgPermissions) {
        return null;
    }
    if (params.permission) {
        return orgPermissions.includes(prefixWithOrg(params.permission));
    }
    if (params.role) {
        return prefixWithOrg(orgRole) === prefixWithOrg(params.role);
    }
    return null;
};
var checkForFeatureOrPlan = (claim, featureOrPlan)=>{
    const { org: orgFeatures, user: userFeatures } = splitByScope(claim);
    const [scope, _id] = featureOrPlan.split(":");
    const id = _id || scope;
    if (scope === "org") {
        return orgFeatures.includes(id);
    } else if (scope === "user") {
        return userFeatures.includes(id);
    } else {
        return [
            ...orgFeatures,
            ...userFeatures
        ].includes(id);
    }
};
var checkBillingAuthorization = (params, options)=>{
    const { features, plans } = options;
    if (params.feature && features) {
        return checkForFeatureOrPlan(features, params.feature);
    }
    if (params.plan && plans) {
        return checkForFeatureOrPlan(plans, params.plan);
    }
    return null;
};
var splitByScope = (fea)=>{
    const features = fea ? fea.split(",").map((f)=>f.trim()) : [];
    return {
        org: features.filter((f)=>f.split(":")[0].includes("o")).map((f)=>f.split(":")[1]),
        user: features.filter((f)=>f.split(":")[0].includes("u")).map((f)=>f.split(":")[1])
    };
};
var validateReverificationConfig = (config)=>{
    if (!config) {
        return false;
    }
    const convertConfigToObject = (config2)=>{
        if (typeof config2 === "string") {
            return TYPES_TO_OBJECTS[config2];
        }
        return config2;
    };
    const isValidStringValue = typeof config === "string" && isValidVerificationType(config);
    const isValidObjectValue = typeof config === "object" && isValidLevel(config.level) && isValidMaxAge(config.afterMinutes);
    if (isValidStringValue || isValidObjectValue) {
        return convertConfigToObject.bind(null, config);
    }
    return false;
};
var checkReverificationAuthorization = (params, { factorVerificationAge })=>{
    if (!params.reverification || !factorVerificationAge) {
        return null;
    }
    const isValidReverification = validateReverificationConfig(params.reverification);
    if (!isValidReverification) {
        return null;
    }
    const { level, afterMinutes } = isValidReverification();
    const [factor1Age, factor2Age] = factorVerificationAge;
    const isValidFactor1 = factor1Age !== -1 ? afterMinutes > factor1Age : null;
    const isValidFactor2 = factor2Age !== -1 ? afterMinutes > factor2Age : null;
    switch(level){
        case "first_factor":
            return isValidFactor1;
        case "second_factor":
            return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;
        case "multi_factor":
            return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;
    }
};
var createCheckAuthorization = (options)=>{
    return (params)=>{
        if (!options.userId) {
            return false;
        }
        const billingAuthorization = checkBillingAuthorization(params, options);
        const orgAuthorization = checkOrgAuthorization(params, options);
        const reverificationAuthorization = checkReverificationAuthorization(params, options);
        if ([
            billingAuthorization || orgAuthorization,
            reverificationAuthorization
        ].some((a)=>a === null)) {
            return [
                billingAuthorization || orgAuthorization,
                reverificationAuthorization
            ].some((a)=>a === true);
        }
        return [
            billingAuthorization || orgAuthorization,
            reverificationAuthorization
        ].every((a)=>a === true);
    };
};
var resolveAuthState = ({ authObject: { sessionId, sessionStatus, userId, actor, orgId, orgRole, orgSlug, signOut, getToken, has, sessionClaims }, options: { treatPendingAsSignedOut = true } })=>{
    if (sessionId === void 0 && userId === void 0) {
        return {
            isLoaded: false,
            isSignedIn: void 0,
            sessionId,
            sessionClaims: void 0,
            userId,
            actor: void 0,
            orgId: void 0,
            orgRole: void 0,
            orgSlug: void 0,
            has: void 0,
            signOut,
            getToken
        };
    }
    if (sessionId === null && userId === null) {
        return {
            isLoaded: true,
            isSignedIn: false,
            sessionId,
            userId,
            sessionClaims: null,
            actor: null,
            orgId: null,
            orgRole: null,
            orgSlug: null,
            has: ()=>false,
            signOut,
            getToken
        };
    }
    if (treatPendingAsSignedOut && sessionStatus === "pending") {
        return {
            isLoaded: true,
            isSignedIn: false,
            sessionId: null,
            userId: null,
            sessionClaims: null,
            actor: null,
            orgId: null,
            orgRole: null,
            orgSlug: null,
            has: ()=>false,
            signOut,
            getToken
        };
    }
    if (!!sessionId && !!sessionClaims && !!userId && !!orgId && !!orgRole) {
        return {
            isLoaded: true,
            isSignedIn: true,
            sessionId,
            sessionClaims,
            userId,
            actor: actor || null,
            orgId,
            orgRole,
            orgSlug: orgSlug || null,
            has,
            signOut,
            getToken
        };
    }
    if (!!sessionId && !!sessionClaims && !!userId && !orgId) {
        return {
            isLoaded: true,
            isSignedIn: true,
            sessionId,
            sessionClaims,
            userId,
            actor: actor || null,
            orgId: null,
            orgRole: null,
            orgSlug: null,
            has,
            signOut,
            getToken
        };
    }
};
;
 //# sourceMappingURL=chunk-3CN5LOSN.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/authorization.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3CN5LOSN$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=authorization.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/authorization.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3CN5LOSN$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$authorization$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/authorization.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/jwtPayloadParser.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "__experimental_JWTPayloadToAuthObjectProperties": ()=>__experimental_JWTPayloadToAuthObjectProperties,
    "parsePermissions": ()=>parsePermissions
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3CN5LOSN$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
// src/jwtPayloadParser.ts
var parsePermissions = ({ per, fpm })=>{
    if (!per || !fpm) {
        return {
            permissions: [],
            featurePermissionMap: []
        };
    }
    const permissions = per.split(",").map((p)=>p.trim());
    const featurePermissionMap = fpm.split(",").map((permission)=>Number.parseInt(permission.trim(), 10)).map((permission)=>permission.toString(2).padStart(permissions.length, "0").split("").map((bit)=>Number.parseInt(bit, 10)).reverse()).filter(Boolean);
    return {
        permissions,
        featurePermissionMap
    };
};
function buildOrgPermissions({ features, permissions, featurePermissionMap }) {
    if (!features || !permissions || !featurePermissionMap) {
        return [];
    }
    const orgPermissions = [];
    for(let featureIndex = 0; featureIndex < features.length; featureIndex++){
        const feature = features[featureIndex];
        if (featureIndex >= featurePermissionMap.length) {
            continue;
        }
        const permissionBits = featurePermissionMap[featureIndex];
        if (!permissionBits) continue;
        for(let permIndex = 0; permIndex < permissionBits.length; permIndex++){
            if (permissionBits[permIndex] === 1) {
                orgPermissions.push(`org:${feature}:${permissions[permIndex]}`);
            }
        }
    }
    return orgPermissions;
}
var __experimental_JWTPayloadToAuthObjectProperties = (claims)=>{
    let orgId;
    let orgRole;
    let orgSlug;
    let orgPermissions;
    const factorVerificationAge = claims.fva ?? null;
    const sessionStatus = claims.sts ?? null;
    switch(claims.v){
        case 2:
            {
                if (claims.o) {
                    orgId = claims.o?.id;
                    orgSlug = claims.o?.slg;
                    if (claims.o?.rol) {
                        orgRole = `org:${claims.o?.rol}`;
                    }
                    const { org } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3CN5LOSN$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["splitByScope"])(claims.fea);
                    const { permissions, featurePermissionMap } = parsePermissions({
                        per: claims.o?.per,
                        fpm: claims.o?.fpm
                    });
                    orgPermissions = buildOrgPermissions({
                        features: org,
                        featurePermissionMap,
                        permissions
                    });
                }
                break;
            }
        default:
            orgId = claims.org_id;
            orgRole = claims.org_role;
            orgSlug = claims.org_slug;
            orgPermissions = claims.org_permissions;
            break;
    }
    return {
        sessionClaims: claims,
        sessionId: claims.sid,
        sessionStatus,
        actor: claims.act,
        userId: claims.sub,
        orgId,
        orgRole,
        orgSlug,
        orgPermissions,
        factorVerificationAge
    };
};
;
 //# sourceMappingURL=jwtPayloadParser.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-JJHTUJGL.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/compiled/path-to-regexp/index.js
__turbopack_context__.s({
    "match": ()=>match,
    "pathToRegexp": ()=>pathToRegexp
});
function _(r) {
    for(var n = [], e = 0; e < r.length;){
        var a = r[e];
        if (a === "*" || a === "+" || a === "?") {
            n.push({
                type: "MODIFIER",
                index: e,
                value: r[e++]
            });
            continue;
        }
        if (a === "\\") {
            n.push({
                type: "ESCAPED_CHAR",
                index: e++,
                value: r[e++]
            });
            continue;
        }
        if (a === "{") {
            n.push({
                type: "OPEN",
                index: e,
                value: r[e++]
            });
            continue;
        }
        if (a === "}") {
            n.push({
                type: "CLOSE",
                index: e,
                value: r[e++]
            });
            continue;
        }
        if (a === ":") {
            for(var u = "", t = e + 1; t < r.length;){
                var c = r.charCodeAt(t);
                if (c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 95) {
                    u += r[t++];
                    continue;
                }
                break;
            }
            if (!u) throw new TypeError("Missing parameter name at ".concat(e));
            n.push({
                type: "NAME",
                index: e,
                value: u
            }), e = t;
            continue;
        }
        if (a === "(") {
            var o = 1, m = "", t = e + 1;
            if (r[t] === "?") throw new TypeError('Pattern cannot start with "?" at '.concat(t));
            for(; t < r.length;){
                if (r[t] === "\\") {
                    m += r[t++] + r[t++];
                    continue;
                }
                if (r[t] === ")") {
                    if (o--, o === 0) {
                        t++;
                        break;
                    }
                } else if (r[t] === "(" && (o++, r[t + 1] !== "?")) throw new TypeError("Capturing groups are not allowed at ".concat(t));
                m += r[t++];
            }
            if (o) throw new TypeError("Unbalanced pattern at ".concat(e));
            if (!m) throw new TypeError("Missing pattern at ".concat(e));
            n.push({
                type: "PATTERN",
                index: e,
                value: m
            }), e = t;
            continue;
        }
        n.push({
            type: "CHAR",
            index: e,
            value: r[e++]
        });
    }
    return n.push({
        type: "END",
        index: e,
        value: ""
    }), n;
}
function F(r, n) {
    n === void 0 && (n = {});
    for(var e = _(r), a = n.prefixes, u = a === void 0 ? "./" : a, t = n.delimiter, c = t === void 0 ? "/#?" : t, o = [], m = 0, h = 0, p = "", f = function(l) {
        if (h < e.length && e[h].type === l) return e[h++].value;
    }, w = function(l) {
        var v = f(l);
        if (v !== void 0) return v;
        var E = e[h], N = E.type, S = E.index;
        throw new TypeError("Unexpected ".concat(N, " at ").concat(S, ", expected ").concat(l));
    }, d = function() {
        for(var l = "", v; v = f("CHAR") || f("ESCAPED_CHAR");)l += v;
        return l;
    }, M = function(l) {
        for(var v = 0, E = c; v < E.length; v++){
            var N = E[v];
            if (l.indexOf(N) > -1) return true;
        }
        return false;
    }, A = function(l) {
        var v = o[o.length - 1], E = l || (v && typeof v == "string" ? v : "");
        if (v && !E) throw new TypeError('Must have text between two parameters, missing text after "'.concat(v.name, '"'));
        return !E || M(E) ? "[^".concat(s(c), "]+?") : "(?:(?!".concat(s(E), ")[^").concat(s(c), "])+?");
    }; h < e.length;){
        var T = f("CHAR"), x = f("NAME"), C = f("PATTERN");
        if (x || C) {
            var g = T || "";
            u.indexOf(g) === -1 && (p += g, g = ""), p && (o.push(p), p = ""), o.push({
                name: x || m++,
                prefix: g,
                suffix: "",
                pattern: C || A(g),
                modifier: f("MODIFIER") || ""
            });
            continue;
        }
        var i = T || f("ESCAPED_CHAR");
        if (i) {
            p += i;
            continue;
        }
        p && (o.push(p), p = "");
        var R = f("OPEN");
        if (R) {
            var g = d(), y = f("NAME") || "", O = f("PATTERN") || "", b = d();
            w("CLOSE"), o.push({
                name: y || (O ? m++ : ""),
                pattern: y && !O ? A(g) : O,
                prefix: g,
                suffix: b,
                modifier: f("MODIFIER") || ""
            });
            continue;
        }
        w("END");
    }
    return o;
}
function H(r, n) {
    var e = [], a = P(r, e, n);
    return I(a, e, n);
}
function I(r, n, e) {
    e === void 0 && (e = {});
    var a = e.decode, u = a === void 0 ? function(t) {
        return t;
    } : a;
    return function(t) {
        var c = r.exec(t);
        if (!c) return false;
        for(var o = c[0], m = c.index, h = /* @__PURE__ */ Object.create(null), p = function(w) {
            if (c[w] === void 0) return "continue";
            var d = n[w - 1];
            d.modifier === "*" || d.modifier === "+" ? h[d.name] = c[w].split(d.prefix + d.suffix).map(function(M) {
                return u(M, d);
            }) : h[d.name] = u(c[w], d);
        }, f = 1; f < c.length; f++)p(f);
        return {
            path: o,
            index: m,
            params: h
        };
    };
}
function s(r) {
    return r.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function D(r) {
    return r && r.sensitive ? "" : "i";
}
function $(r, n) {
    if (!n) return r;
    for(var e = /\((?:\?<(.*?)>)?(?!\?)/g, a = 0, u = e.exec(r.source); u;)n.push({
        name: u[1] || a++,
        prefix: "",
        suffix: "",
        modifier: "",
        pattern: ""
    }), u = e.exec(r.source);
    return r;
}
function W(r, n, e) {
    var a = r.map(function(u) {
        return P(u, n, e).source;
    });
    return new RegExp("(?:".concat(a.join("|"), ")"), D(e));
}
function L(r, n, e) {
    return U(F(r, e), n, e);
}
function U(r, n, e) {
    e === void 0 && (e = {});
    for(var a = e.strict, u = a === void 0 ? false : a, t = e.start, c = t === void 0 ? true : t, o = e.end, m = o === void 0 ? true : o, h = e.encode, p = h === void 0 ? function(v) {
        return v;
    } : h, f = e.delimiter, w = f === void 0 ? "/#?" : f, d = e.endsWith, M = d === void 0 ? "" : d, A = "[".concat(s(M), "]|$"), T = "[".concat(s(w), "]"), x = c ? "^" : "", C = 0, g = r; C < g.length; C++){
        var i = g[C];
        if (typeof i == "string") x += s(p(i));
        else {
            var R = s(p(i.prefix)), y = s(p(i.suffix));
            if (i.pattern) if (n && n.push(i), R || y) if (i.modifier === "+" || i.modifier === "*") {
                var O = i.modifier === "*" ? "?" : "";
                x += "(?:".concat(R, "((?:").concat(i.pattern, ")(?:").concat(y).concat(R, "(?:").concat(i.pattern, "))*)").concat(y, ")").concat(O);
            } else x += "(?:".concat(R, "(").concat(i.pattern, ")").concat(y, ")").concat(i.modifier);
            else {
                if (i.modifier === "+" || i.modifier === "*") throw new TypeError('Can not repeat "'.concat(i.name, '" without a prefix and suffix'));
                x += "(".concat(i.pattern, ")").concat(i.modifier);
            }
            else x += "(?:".concat(R).concat(y, ")").concat(i.modifier);
        }
    }
    if (m) u || (x += "".concat(T, "?")), x += e.endsWith ? "(?=".concat(A, ")") : "$";
    else {
        var b = r[r.length - 1], l = typeof b == "string" ? T.indexOf(b[b.length - 1]) > -1 : b === void 0;
        u || (x += "(?:".concat(T, "(?=").concat(A, "))?")), l || (x += "(?=".concat(T, "|").concat(A, ")"));
    }
    return new RegExp(x, D(e));
}
function P(r, n, e) {
    return r instanceof RegExp ? $(r, n) : Array.isArray(r) ? W(r, n, e) : L(r, n, e);
}
// src/pathToRegexp.ts
var pathToRegexp = (path)=>{
    try {
        return P(path);
    } catch (e) {
        throw new Error(`Invalid path: ${path}.
Consult the documentation of path-to-regexp here: https://github.com/pillarjs/path-to-regexp/tree/6.x
${e.message}`);
    }
};
function match(str, options) {
    try {
        return H(str, options);
    } catch (e) {
        throw new Error(`Invalid path and options: Consult the documentation of path-to-regexp here: https://github.com/pillarjs/path-to-regexp/tree/6.x
${e.message}`);
    }
}
;
 //# sourceMappingURL=chunk-JJHTUJGL.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/pathToRegexp.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$JJHTUJGL$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-JJHTUJGL.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=pathToRegexp.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/pathToRegexp.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$JJHTUJGL$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-JJHTUJGL.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$pathToRegexp$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/pathToRegexp.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/authorization-errors.ts
__turbopack_context__.s({
    "isReverificationHint": ()=>isReverificationHint,
    "reverificationError": ()=>reverificationError,
    "reverificationErrorResponse": ()=>reverificationErrorResponse
});
var REVERIFICATION_REASON = "reverification-error";
var reverificationError = (missingConfig)=>({
        clerk_error: {
            type: "forbidden",
            reason: REVERIFICATION_REASON,
            metadata: {
                reverification: missingConfig
            }
        }
    });
var reverificationErrorResponse = (...args)=>new Response(JSON.stringify(reverificationError(...args)), {
        status: 403
    });
var isReverificationHint = (result)=>{
    return result && typeof result === "object" && "clerk_error" in result && result.clerk_error?.type === "forbidden" && result.clerk_error?.reason === REVERIFICATION_REASON;
};
;
 //# sourceMappingURL=chunk-43A5F2IE.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/authorization-errors.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$43A5F2IE$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=authorization-errors.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/authorization-errors.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$43A5F2IE$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-43A5F2IE.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$authorization$2d$errors$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/authorization-errors.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/underscore.ts
__turbopack_context__.s({
    "camelToSnake": ()=>camelToSnake,
    "deepCamelToSnake": ()=>deepCamelToSnake,
    "deepSnakeToCamel": ()=>deepSnakeToCamel,
    "getNonUndefinedValues": ()=>getNonUndefinedValues,
    "isIPV4Address": ()=>isIPV4Address,
    "isTruthy": ()=>isTruthy,
    "snakeToCamel": ()=>snakeToCamel,
    "titleize": ()=>titleize,
    "toSentence": ()=>toSentence
});
var toSentence = (items)=>{
    if (items.length == 0) {
        return "";
    }
    if (items.length == 1) {
        return items[0];
    }
    let sentence = items.slice(0, -1).join(", ");
    sentence += `, or ${items.slice(-1)}`;
    return sentence;
};
var IP_V4_ADDRESS_REGEX = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
function isIPV4Address(str) {
    return IP_V4_ADDRESS_REGEX.test(str || "");
}
function titleize(str) {
    const s = str || "";
    return s.charAt(0).toUpperCase() + s.slice(1);
}
function snakeToCamel(str) {
    return str ? str.replace(/([-_][a-z])/g, (match)=>match.toUpperCase().replace(/-|_/, "")) : "";
}
function camelToSnake(str) {
    return str ? str.replace(/[A-Z]/g, (letter)=>`_${letter.toLowerCase()}`) : "";
}
var createDeepObjectTransformer = (transform)=>{
    const deepTransform = (obj)=>{
        if (!obj) {
            return obj;
        }
        if (Array.isArray(obj)) {
            return obj.map((el)=>{
                if (typeof el === "object" || Array.isArray(el)) {
                    return deepTransform(el);
                }
                return el;
            });
        }
        const copy = {
            ...obj
        };
        const keys = Object.keys(copy);
        for (const oldName of keys){
            const newName = transform(oldName.toString());
            if (newName !== oldName) {
                copy[newName] = copy[oldName];
                delete copy[oldName];
            }
            if (typeof copy[newName] === "object") {
                copy[newName] = deepTransform(copy[newName]);
            }
        }
        return copy;
    };
    return deepTransform;
};
var deepCamelToSnake = createDeepObjectTransformer(camelToSnake);
var deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);
function isTruthy(value) {
    if (typeof value === `boolean`) {
        return value;
    }
    if (value === void 0 || value === null) {
        return false;
    }
    if (typeof value === `string`) {
        if (value.toLowerCase() === `true`) {
            return true;
        }
        if (value.toLowerCase() === `false`) {
            return false;
        }
    }
    const number = parseInt(value, 10);
    if (isNaN(number)) {
        return false;
    }
    if (number > 0) {
        return true;
    }
    return false;
}
function getNonUndefinedValues(obj) {
    return Object.entries(obj).reduce((acc, [key, value])=>{
        if (value !== void 0) {
            acc[key] = value;
        }
        return acc;
    }, {});
}
;
 //# sourceMappingURL=chunk-GGFRMWFO.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-CEMKEFAA.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "TelemetryCollector": ()=>TelemetryCollector,
    "eventComponentMounted": ()=>eventComponentMounted,
    "eventFrameworkMetadata": ()=>eventFrameworkMetadata,
    "eventMethodCalled": ()=>eventMethodCalled,
    "eventPrebuiltComponentMounted": ()=>eventPrebuiltComponentMounted,
    "eventPrebuiltComponentOpened": ()=>eventPrebuiltComponentOpened
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
// src/telemetry/throttler.ts
var DEFAULT_CACHE_TTL_MS = 864e5;
var _storageKey, _cacheTtl, _TelemetryEventThrottler_instances, generateKey_fn, cache_get, isValidBrowser_get;
var TelemetryEventThrottler = class {
    constructor(){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _TelemetryEventThrottler_instances);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _storageKey, "clerk_telemetry_throttler");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _cacheTtl, DEFAULT_CACHE_TTL_MS);
    }
    isEventThrottled(payload) {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _TelemetryEventThrottler_instances, isValidBrowser_get)) {
            return false;
        }
        const now = Date.now();
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryEventThrottler_instances, generateKey_fn).call(this, payload);
        const entry = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _TelemetryEventThrottler_instances, cache_get)?.[key];
        if (!entry) {
            const updatedCache = {
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _TelemetryEventThrottler_instances, cache_get),
                [key]: now
            };
            localStorage.setItem((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _storageKey), JSON.stringify(updatedCache));
        }
        const shouldInvalidate = entry && now - entry > (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _cacheTtl);
        if (shouldInvalidate) {
            const updatedCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _TelemetryEventThrottler_instances, cache_get);
            delete updatedCache[key];
            localStorage.setItem((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _storageKey), JSON.stringify(updatedCache));
        }
        return !!entry;
    }
};
_storageKey = new WeakMap();
_cacheTtl = new WeakMap();
_TelemetryEventThrottler_instances = new WeakSet();
/**
 * Generates a consistent unique key for telemetry events by sorting payload properties.
 * This ensures that payloads with identical content in different orders produce the same key.
 */ generateKey_fn = function(event) {
    const { sk: _sk, pk: _pk, payload, ...rest } = event;
    const sanitizedEvent = {
        ...payload,
        ...rest
    };
    return JSON.stringify(Object.keys({
        ...payload,
        ...rest
    }).sort().map((key)=>sanitizedEvent[key]));
};
cache_get = function() {
    const cacheString = localStorage.getItem((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _storageKey));
    if (!cacheString) {
        return {};
    }
    return JSON.parse(cacheString);
};
isValidBrowser_get = function() {
    if ("TURBOPACK compile-time truthy", 1) {
        return false;
    }
    //TURBOPACK unreachable
    ;
    const storage = undefined;
};
// src/telemetry/collector.ts
function isWindowClerkWithMetadata(clerk) {
    return typeof clerk === "object" && clerk !== null && "constructor" in clerk && typeof clerk.constructor === "function";
}
var DEFAULT_CONFIG = {
    samplingRate: 1,
    maxBufferSize: 5,
    // Production endpoint: https://clerk-telemetry.com
    // Staging endpoint: https://staging.clerk-telemetry.com
    // Local: http://localhost:8787
    endpoint: "https://clerk-telemetry.com"
};
var _config, _eventThrottler, _metadata, _buffer, _pendingFlush, _TelemetryCollector_instances, shouldRecord_fn, shouldBeSampled_fn, scheduleFlush_fn, flush_fn, logEvent_fn, getSDKMetadata_fn, preparePayload_fn;
var TelemetryCollector = class {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _TelemetryCollector_instances);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _config);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _eventThrottler);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _metadata, {});
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _buffer, []);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _pendingFlush);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateSet"])(this, _config, {
            maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,
            samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,
            perEventSampling: options.perEventSampling ?? true,
            disabled: options.disabled ?? false,
            debug: options.debug ?? false,
            endpoint: DEFAULT_CONFIG.endpoint
        });
        if (!options.clerkVersion && "undefined" === "undefined") {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).clerkVersion = "";
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).clerkVersion = options.clerkVersion ?? "";
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).sdk = options.sdk;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).sdkVersion = options.sdkVersion;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).publishableKey = options.publishableKey ?? "";
        const parsedKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePublishableKey"])(options.publishableKey);
        if (parsedKey) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).instanceType = parsedKey.instanceType;
        }
        if (options.secretKey) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).secretKey = options.secretKey.substring(0, 16);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateSet"])(this, _eventThrottler, new TelemetryEventThrottler());
    }
    get isEnabled() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).instanceType !== "development") {
            return false;
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _config).disabled || typeof process !== "undefined" && process.env && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTruthy"])(process.env.CLERK_TELEMETRY_DISABLED)) {
            return false;
        }
        if ("undefined" !== "undefined" && !!window?.navigator?.webdriver) //TURBOPACK unreachable
        ;
        return true;
    }
    get isDebug() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _config).debug || typeof process !== "undefined" && process.env && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isTruthy"])(process.env.CLERK_TELEMETRY_DEBUG);
    }
    record(event) {
        const preparedPayload = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, preparePayload_fn).call(this, event.event, event.payload);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, logEvent_fn).call(this, preparedPayload.event, preparedPayload);
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, shouldRecord_fn).call(this, preparedPayload, event.eventSamplingRate)) {
            return;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _buffer).push(preparedPayload);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, scheduleFlush_fn).call(this);
    }
};
_config = new WeakMap();
_eventThrottler = new WeakMap();
_metadata = new WeakMap();
_buffer = new WeakMap();
_pendingFlush = new WeakMap();
_TelemetryCollector_instances = new WeakSet();
shouldRecord_fn = function(preparedPayload, eventSamplingRate) {
    return this.isEnabled && !this.isDebug && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);
};
shouldBeSampled_fn = function(preparedPayload, eventSamplingRate) {
    const randomSeed = Math.random();
    const toBeSampled = randomSeed <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _config).samplingRate && ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _config).perEventSampling === false || typeof eventSamplingRate === "undefined" || randomSeed <= eventSamplingRate);
    if (!toBeSampled) {
        return false;
    }
    return !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _eventThrottler).isEventThrottled(preparedPayload);
};
scheduleFlush_fn = function() {
    if ("TURBOPACK compile-time truthy", 1) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, flush_fn).call(this);
        return;
    }
    //TURBOPACK unreachable
    ;
    const isBufferFull = undefined;
};
flush_fn = function() {
    const eventsToSend = [
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _buffer)
    ];
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateSet"])(this, _buffer, []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateSet"])(this, _pendingFlush, null);
    if (eventsToSend.length === 0) {
        return;
    }
    fetch(new URL("/v1/event", (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _config).endpoint), {
        method: "POST",
        // TODO: We send an array here with that idea that we can eventually send multiple events.
        body: JSON.stringify({
            events: eventsToSend
        }),
        keepalive: true,
        headers: {
            "Content-Type": "application/json"
        }
    }).catch(()=>void 0);
};
/**
 * If running in debug mode, log the event and its payload to the console.
 */ logEvent_fn = function(event, payload) {
    if (!this.isDebug) {
        return;
    }
    if (typeof console.groupCollapsed !== "undefined") {
        console.groupCollapsed("[clerk/telemetry]", event);
        console.log(payload);
        console.groupEnd();
    } else {
        console.log("[clerk/telemetry]", event, payload);
    }
};
/**
 * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.
 *
 * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.
 */ getSDKMetadata_fn = function() {
    const sdkMetadata = {
        name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).sdk,
        version: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).sdkVersion
    };
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return sdkMetadata;
};
/**
 * Append relevant metadata from the Clerk singleton to the event payload.
 */ preparePayload_fn = function(event, payload) {
    const sdkMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);
    return {
        event,
        cv: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).clerkVersion ?? "",
        it: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).instanceType ?? "",
        sdk: sdkMetadata.name,
        sdkv: sdkMetadata.version,
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).publishableKey ? {
            pk: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).publishableKey
        } : {},
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).secretKey ? {
            sk: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["__privateGet"])(this, _metadata).secretKey
        } : {},
        payload
    };
};
// src/telemetry/events/component-mounted.ts
var EVENT_COMPONENT_MOUNTED = "COMPONENT_MOUNTED";
var EVENT_COMPONENT_OPENED = "COMPONENT_OPENED";
var EVENT_SAMPLING_RATE = 0.1;
function createPrebuiltComponentEvent(event) {
    return function(component, props, additionalPayload) {
        return {
            event,
            eventSamplingRate: EVENT_SAMPLING_RATE,
            payload: {
                component,
                appearanceProp: Boolean(props?.appearance),
                baseTheme: Boolean(props?.appearance?.baseTheme),
                elements: Boolean(props?.appearance?.elements),
                variables: Boolean(props?.appearance?.variables),
                ...additionalPayload
            }
        };
    };
}
function eventPrebuiltComponentMounted(component, props, additionalPayload) {
    return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);
}
function eventPrebuiltComponentOpened(component, props, additionalPayload) {
    return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);
}
function eventComponentMounted(component, props = {}) {
    return {
        event: EVENT_COMPONENT_MOUNTED,
        eventSamplingRate: EVENT_SAMPLING_RATE,
        payload: {
            component,
            ...props
        }
    };
}
// src/telemetry/events/method-called.ts
var EVENT_METHOD_CALLED = "METHOD_CALLED";
var EVENT_SAMPLING_RATE2 = 0.1;
function eventMethodCalled(method, payload) {
    return {
        event: EVENT_METHOD_CALLED,
        eventSamplingRate: EVENT_SAMPLING_RATE2,
        payload: {
            method,
            ...payload
        }
    };
}
// src/telemetry/events/framework-metadata.ts
var EVENT_FRAMEWORK_METADATA = "FRAMEWORK_METADATA";
var EVENT_SAMPLING_RATE3 = 0.1;
function eventFrameworkMetadata(payload) {
    return {
        event: EVENT_FRAMEWORK_METADATA,
        eventSamplingRate: EVENT_SAMPLING_RATE3,
        payload
    };
}
;
 //# sourceMappingURL=chunk-CEMKEFAA.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/telemetry.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$CEMKEFAA$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-CEMKEFAA.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
 //# sourceMappingURL=telemetry.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/telemetry.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$CEMKEFAA$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-CEMKEFAA.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$telemetry$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/telemetry.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-BLFJDBCF.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "apiUrlFromPublishableKey": ()=>apiUrlFromPublishableKey
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
;
;
// src/apiUrlFromPublishableKey.ts
var apiUrlFromPublishableKey = (publishableKey)=>{
    const frontendApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parsePublishableKey"])(publishableKey)?.frontendApi;
    if (frontendApi?.startsWith("clerk.") && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LEGACY_DEV_INSTANCE_SUFFIXES"].some((suffix)=>frontendApi?.endsWith(suffix))) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PROD_API_URL"];
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LOCAL_ENV_SUFFIXES"].some((suffix)=>frontendApi?.endsWith(suffix))) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["LOCAL_API_URL"];
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["STAGING_ENV_SUFFIXES"].some((suffix)=>frontendApi?.endsWith(suffix))) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["STAGING_API_URL"];
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PROD_API_URL"];
};
;
 //# sourceMappingURL=chunk-BLFJDBCF.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/apiUrlFromPublishableKey.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$BLFJDBCF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-BLFJDBCF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
 //# sourceMappingURL=apiUrlFromPublishableKey.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/apiUrlFromPublishableKey.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$BLFJDBCF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-BLFJDBCF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$IV7BOO4U$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$TETGTEI2$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$KOH7GTJO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-KOH7GTJO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$I6MTSTOF$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$apiUrlFromPublishableKey$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/apiUrlFromPublishableKey.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/underscore.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=underscore.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/underscore.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$GGFRMWFO$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$underscore$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/underscore.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/logger.ts
__turbopack_context__.s({
    "logger": ()=>logger
});
var loggedMessages = /* @__PURE__ */ new Set();
var logger = {
    /**
   * A custom logger that ensures messages are logged only once.
   * Reduces noise and duplicated messages when logs are in a hot codepath.
   */ warnOnce: (msg)=>{
        if (loggedMessages.has(msg)) {
            return;
        }
        loggedMessages.add(msg);
        console.warn(msg);
    },
    logOnce: (msg)=>{
        if (loggedMessages.has(msg)) {
            return;
        }
        console.log(msg);
        loggedMessages.add(msg);
    }
};
;
 //# sourceMappingURL=chunk-CYDR2ZSA.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/logger.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$CYDR2ZSA$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=logger.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/logger.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$CYDR2ZSA$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-CYDR2ZSA.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$logger$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/logger.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/proxy.ts
__turbopack_context__.s({
    "isHttpOrHttps": ()=>isHttpOrHttps,
    "isProxyUrlRelative": ()=>isProxyUrlRelative,
    "isValidProxyUrl": ()=>isValidProxyUrl,
    "proxyUrlToAbsoluteURL": ()=>proxyUrlToAbsoluteURL
});
function isValidProxyUrl(key) {
    if (!key) {
        return true;
    }
    return isHttpOrHttps(key) || isProxyUrlRelative(key);
}
function isHttpOrHttps(key) {
    return /^http(s)?:\/\//.test(key || "");
}
function isProxyUrlRelative(key) {
    return key.startsWith("/");
}
function proxyUrlToAbsoluteURL(url) {
    if (!url) {
        return "";
    }
    return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;
}
;
 //# sourceMappingURL=chunk-6NDGN2IU.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/proxy.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$6NDGN2IU$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
 //# sourceMappingURL=proxy.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/proxy.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$6NDGN2IU$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$proxy$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/proxy.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "allSettled": ()=>allSettled,
    "fastDeepMergeAndKeep": ()=>fastDeepMergeAndKeep,
    "fastDeepMergeAndReplace": ()=>fastDeepMergeAndReplace,
    "logErrorInDevMode": ()=>logErrorInDevMode
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)");
;
// src/utils/allSettled.ts
function allSettled(iterable) {
    const promises = Array.from(iterable).map((p)=>p.then((value)=>({
                status: "fulfilled",
                value
            }), (reason)=>({
                status: "rejected",
                reason
            })));
    return Promise.all(promises);
}
// src/utils/logErrorInDevMode.ts
var logErrorInDevMode = (message)=>{
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isDevelopmentEnvironment"])()) {
        console.error(`Clerk: ${message}`);
    }
};
// src/utils/fastDeepMerge.ts
var fastDeepMergeAndReplace = (source, target)=>{
    if (!source || !target) {
        return;
    }
    for(const key in source){
        if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {
            if (target[key] === void 0) {
                target[key] = new (Object.getPrototypeOf(source[key])).constructor();
            }
            fastDeepMergeAndReplace(source[key], target[key]);
        } else if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
        }
    }
};
var fastDeepMergeAndKeep = (source, target)=>{
    if (!source || !target) {
        return;
    }
    for(const key in source){
        if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {
            if (target[key] === void 0) {
                target[key] = new (Object.getPrototypeOf(source[key])).constructor();
            }
            fastDeepMergeAndKeep(source[key], target[key]);
        } else if (Object.prototype.hasOwnProperty.call(source, key) && target[key] === void 0) {
            target[key] = source[key];
        }
    }
};
;
 //# sourceMappingURL=chunk-ARQUL5DC.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/noop.ts
__turbopack_context__.s({
    "noop": ()=>noop
});
var noop = (..._args)=>{};
;
 //# sourceMappingURL=chunk-7FNX7RWY.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "createDeferredPromise": ()=>createDeferredPromise
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7FNX7RWY$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs [app-route] (ecmascript)");
;
// src/utils/createDeferredPromise.ts
var createDeferredPromise = ()=>{
    let resolve = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7FNX7RWY$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["noop"];
    let reject = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7FNX7RWY$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["noop"];
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
};
;
 //# sourceMappingURL=chunk-7QJ2QTJL.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

// src/utils/handleValueOrFn.ts
__turbopack_context__.s({
    "handleValueOrFn": ()=>handleValueOrFn
});
function handleValueOrFn(value, url, defaultValue) {
    if (typeof value === "function") {
        return value(url);
    }
    if (typeof value !== "undefined") {
        return value;
    }
    if (typeof defaultValue !== "undefined") {
        return defaultValue;
    }
    return void 0;
}
;
 //# sourceMappingURL=chunk-O32JQBM6.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/utils/index.mjs [app-route] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$ARQUL5DC$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7QJ2QTJL$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7FNX7RWY$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3TMSNP4L$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$O32JQBM6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@clerk/shared/dist/utils/index.mjs [app-route] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$ARQUL5DC$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7QJ2QTJL$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7QJ2QTJL.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7FNX7RWY$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7FNX7RWY.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$3TMSNP4L$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-3TMSNP4L.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$O32JQBM6$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-O32JQBM6.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7HPDNZ3R$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$chunk$2d$7ELT755Q$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$shared$2f$dist$2f$utils$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@clerk/shared/dist/utils/index.mjs [app-route] (ecmascript) <locals>");
}),
"[project]/node_modules/cookie/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parse = parse;
exports.serialize = serialize;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */ const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */ const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */ const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */ const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */ (()=>{
    const C = function() {};
    C.prototype = Object.create(null);
    return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */ function parse(str, options) {
    const obj = new NullObject();
    const len = str.length;
    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
    if (len < 2) return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
        const eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) break; // No more cookie pairs.
        const colonIdx = str.indexOf(";", index);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);
        // only assign once
        if (obj[key] === undefined) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
        }
        index = endIdx + 1;
    }while (index < len)
    return obj;
}
function startIndex(str, index, max) {
    do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index;
    }while (++index < max)
    return max;
}
function endIndex(str, index, min) {
    while(index > min){
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */  && code !== 0x09 /* \t */ ) return index + 1;
    }
    return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */ function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options) return str;
    if (options.maxAge !== undefined) {
        if (!Number.isInteger(options.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
        }
        str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
        if (!domainValueRegExp.test(options.domain)) {
            throw new TypeError(`option domain is invalid: ${options.domain}`);
        }
        str += "; Domain=" + options.domain;
    }
    if (options.path) {
        if (!pathValueRegExp.test(options.path)) {
            throw new TypeError(`option path is invalid: ${options.path}`);
        }
        str += "; Path=" + options.path;
    }
    if (options.expires) {
        if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options.expires}`);
        }
        str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
        str += "; HttpOnly";
    }
    if (options.secure) {
        str += "; Secure";
    }
    if (options.partitioned) {
        str += "; Partitioned";
    }
    if (options.priority) {
        const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
        switch(priority){
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${options.priority}`);
        }
    }
    if (options.sameSite) {
        const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
        switch(sameSite){
            case true:
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */ function decode(str) {
    if (str.indexOf("%") === -1) return str;
    try {
        return decodeURIComponent(str);
    } catch (e) {
        return str;
    }
}
/**
 * Determine if value is a Date.
 */ function isDate(val) {
    return __toString.call(val) === "[object Date]";
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/jwt-decode/build/esm/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "InvalidTokenError": ()=>InvalidTokenError,
    "jwtDecode": ()=>jwtDecode
});
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p)=>{
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
            code = "0" + code;
        }
        return "%" + code;
    }));
}
function base64UrlDecode(str) {
    let output = str.replace(/-/g, "+").replace(/_/g, "/");
    switch(output.length % 4){
        case 0:
            break;
        case 2:
            output += "==";
            break;
        case 3:
            output += "=";
            break;
        default:
            throw new Error("base64 string is not of the correct length");
    }
    try {
        return b64DecodeUnicode(output);
    } catch (err) {
        return atob(output);
    }
}
function jwtDecode(token, options) {
    if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified: must be a string");
    }
    options || (options = {});
    const pos = options.header === true ? 0 : 1;
    const part = token.split(".")[pos];
    if (typeof part !== "string") {
        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
    }
    let decoded;
    try {
        decoded = base64UrlDecode(part);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
    }
    try {
        return JSON.parse(decoded);
    } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
    }
}
}),
"[project]/node_modules/@discordjs/util/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "calculateShardId": ()=>calculateShardId,
    "getUserAgentAppendix": ()=>getUserAgentAppendix,
    "isEquatable": ()=>isEquatable,
    "isJSONEncodable": ()=>isJSONEncodable,
    "lazy": ()=>lazy,
    "polyfillDispose": ()=>polyfillDispose,
    "range": ()=>range,
    "shouldUseGlobalFetchAndWebSocket": ()=>shouldUseGlobalFetchAndWebSocket,
    "version": ()=>version
});
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
// src/functions/lazy.ts
function lazy(cb) {
    let defaultValue;
    return ()=>defaultValue ??= cb();
}
__name(lazy, "lazy");
// src/functions/range.ts
function* range(range2) {
    let rangeEnd;
    let start = 0;
    let step = 1;
    if (typeof range2 === "number") {
        rangeEnd = range2;
    } else {
        start = range2.start;
        rangeEnd = range2.end;
        step = range2.step ?? 1;
    }
    for(let index = start; index < rangeEnd; index += step){
        yield index;
    }
}
__name(range, "range");
// src/functions/calculateShardId.ts
function calculateShardId(guildId, shardCount) {
    return Number(BigInt(guildId) >> 22n) % shardCount;
}
__name(calculateShardId, "calculateShardId");
// src/functions/runtime.ts
function shouldUseGlobalFetchAndWebSocket() {
    if (typeof globalThis.process === "undefined") {
        return "fetch" in globalThis && "WebSocket" in globalThis;
    }
    if ("versions" in globalThis.process) {
        return "deno" in globalThis.process.versions || "bun" in globalThis.process.versions;
    }
    return false;
}
__name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
// src/functions/userAgentAppendix.ts
function getUserAgentAppendix() {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
        return "Vercel-Edge-Functions";
    }
    if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
        return "Cloudflare-Workers";
    }
    if (typeof globalThis.Netlify !== "undefined") {
        return "Netlify-Edge-Functions";
    }
    if (typeof globalThis.process !== "object") {
        if (typeof globalThis.navigator === "object") {
            return globalThis.navigator.userAgent;
        }
        return "UnknownEnvironment";
    }
    if ("versions" in globalThis.process) {
        if ("deno" in globalThis.process.versions) {
            return `Deno/${globalThis.process.versions.deno}`;
        }
        if ("bun" in globalThis.process.versions) {
            return `Bun/${globalThis.process.versions.bun}`;
        }
        if ("node" in globalThis.process.versions) {
            return `Node.js/${globalThis.process.versions.node}`;
        }
    }
    return "UnknownEnvironment";
}
__name(getUserAgentAppendix, "getUserAgentAppendix");
// src/functions/polyfillDispose.ts
function polyfillDispose() {
    Symbol.dispose ??= Symbol("Symbol.dispose");
    Symbol.asyncDispose ??= Symbol("Symbol.asyncDispose");
}
__name(polyfillDispose, "polyfillDispose");
// src/JSONEncodable.ts
function isJSONEncodable(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
}
__name(isJSONEncodable, "isJSONEncodable");
// src/Equatable.ts
function isEquatable(maybeEquatable) {
    return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
}
__name(isEquatable, "isEquatable");
// src/index.ts
var version = "1.1.1";
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "Collection": ()=>Collection,
    "version": ()=>version
});
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
// src/collection.ts
var Collection = class _Collection extends Map {
    static{
        __name(this, "Collection");
    }
    /**
   * Obtains the value of the given key if it exists, otherwise sets and returns the value provided by the default value generator.
   *
   * @param key - The key to get if it exists, or set otherwise
   * @param defaultValueGenerator - A function that generates the default value
   * @example
   * ```ts
   * collection.ensure(guildId, () => defaultGuildConfig);
   * ```
   */ ensure(key, defaultValueGenerator) {
        if (this.has(key)) return this.get(key);
        if (typeof defaultValueGenerator !== "function") throw new TypeError(`${defaultValueGenerator} is not a function`);
        const defaultValue = defaultValueGenerator(key, this);
        this.set(key, defaultValue);
        return defaultValue;
    }
    /**
   * Checks if all of the elements exist in the collection.
   *
   * @param keys - The keys of the elements to check for
   * @returns `true` if all of the elements exist, `false` if at least one does not exist.
   */ hasAll(...keys) {
        return keys.every((key)=>super.has(key));
    }
    /**
   * Checks if any of the elements exist in the collection.
   *
   * @param keys - The keys of the elements to check for
   * @returns `true` if any of the elements exist, `false` if none exist.
   */ hasAny(...keys) {
        return keys.some((key)=>super.has(key));
    }
    first(amount) {
        if (amount === void 0) return this.values().next().value;
        if (amount < 0) return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({
            length: amount
        }, ()=>iter.next().value);
    }
    firstKey(amount) {
        if (amount === void 0) return this.keys().next().value;
        if (amount < 0) return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({
            length: amount
        }, ()=>iter.next().value);
    }
    last(amount) {
        const arr = [
            ...this.values()
        ];
        if (amount === void 0) return arr[arr.length - 1];
        if (amount < 0) return this.first(amount * -1);
        if (!amount) return [];
        return arr.slice(-amount);
    }
    lastKey(amount) {
        const arr = [
            ...this.keys()
        ];
        if (amount === void 0) return arr[arr.length - 1];
        if (amount < 0) return this.firstKey(amount * -1);
        if (!amount) return [];
        return arr.slice(-amount);
    }
    /**
   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
   * Returns the item at a given index, allowing for positive and negative integers.
   * Negative integers count back from the last item in the collection.
   *
   * @param index - The index of the element to obtain
   */ at(index) {
        index = Math.floor(index);
        const arr = [
            ...this.values()
        ];
        return arr.at(index);
    }
    /**
   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.at()}.
   * Returns the key at a given index, allowing for positive and negative integers.
   * Negative integers count back from the last item in the collection.
   *
   * @param index - The index of the key to obtain
   */ keyAt(index) {
        index = Math.floor(index);
        const arr = [
            ...this.keys()
        ];
        return arr.at(index);
    }
    random(amount) {
        const arr = [
            ...this.values()
        ];
        if (amount === void 0) return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount) return [];
        return Array.from({
            length: Math.min(amount, arr.length)
        }, ()=>arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
        const arr = [
            ...this.keys()
        ];
        if (amount === void 0) return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount) return [];
        return Array.from({
            length: Math.min(amount, arr.length)
        }, ()=>arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    /**
   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse | Array.reverse()}
   * but returns a Collection instead of an Array.
   */ reverse() {
        const entries = [
            ...this.entries()
        ].reverse();
        this.clear();
        for (const [key, value] of entries)this.set(key, value);
        return this;
    }
    find(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        for (const [key, val] of this){
            if (fn(val, key, this)) return val;
        }
        return void 0;
    }
    findKey(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        for (const [key, val] of this){
            if (fn(val, key, this)) return key;
        }
        return void 0;
    }
    findLast(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const entries = [
            ...this.entries()
        ];
        for(let index = entries.length - 1; index >= 0; index--){
            const val = entries[index][1];
            const key = entries[index][0];
            if (fn(val, key, this)) return val;
        }
        return void 0;
    }
    findLastKey(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const entries = [
            ...this.entries()
        ];
        for(let index = entries.length - 1; index >= 0; index--){
            const key = entries[index][0];
            const val = entries[index][1];
            if (fn(val, key, this)) return key;
        }
        return void 0;
    }
    sweep(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this){
            if (fn(val, key, this)) this.delete(key);
        }
        return previousSize - this.size;
    }
    filter(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this){
            if (fn(val, key, this)) results.set(key, val);
        }
        return results;
    }
    partition(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const results = [
            new this.constructor[Symbol.species](),
            new this.constructor[Symbol.species]()
        ];
        for (const [key, val] of this){
            if (fn(val, key, this)) {
                results[0].set(key, val);
            } else {
                results[1].set(key, val);
            }
        }
        return results;
    }
    flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({
            length: this.size
        }, ()=>{
            const [key, value] = iter.next().value;
            return fn(value, key, this);
        });
    }
    mapValues(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)coll.set(key, fn(val, key, this));
        return coll;
    }
    some(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        for (const [key, val] of this){
            if (fn(val, key, this)) return true;
        }
        return false;
    }
    every(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        for (const [key, val] of this){
            if (!fn(val, key, this)) return false;
        }
        return true;
    }
    reduce(fn, initialValue) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        let accumulator;
        const iterator = this.entries();
        if (initialValue === void 0) {
            if (this.size === 0) throw new TypeError("Reduce of empty collection with no initial value");
            accumulator = iterator.next().value[1];
        } else {
            accumulator = initialValue;
        }
        for (const [key, value] of iterator){
            accumulator = fn(accumulator, value, key, this);
        }
        return accumulator;
    }
    reduceRight(fn, initialValue) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        const entries = [
            ...this.entries()
        ];
        let accumulator;
        let index;
        if (initialValue === void 0) {
            if (entries.length === 0) throw new TypeError("Reduce of empty collection with no initial value");
            accumulator = entries[entries.length - 1][1];
            index = entries.length - 1;
        } else {
            accumulator = initialValue;
            index = entries.length;
        }
        while(--index >= 0){
            const key = entries[index][0];
            const val = entries[index][1];
            accumulator = fn(accumulator, val, key, this);
        }
        return accumulator;
    }
    each(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        for (const [key, value] of this){
            fn(value, key, this);
        }
        return this;
    }
    tap(fn, thisArg) {
        if (typeof fn !== "function") throw new TypeError(`${fn} is not a function`);
        if (thisArg !== void 0) fn = fn.bind(thisArg);
        fn(this);
        return this;
    }
    /**
   * Creates an identical shallow copy of this collection.
   *
   * @example
   * ```ts
   * const newColl = someColl.clone();
   * ```
   */ clone() {
        return new this.constructor[Symbol.species](this);
    }
    /**
   * Combines this collection with others into a new collection. None of the source collections are modified.
   *
   * @param collections - Collections to merge
   * @example
   * ```ts
   * const newColl = someColl.concat(someOtherColl, anotherColl, ohBoyAColl);
   * ```
   */ concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections){
            for (const [key, val] of coll)newColl.set(key, val);
        }
        return newColl;
    }
    /**
   * Checks if this collection shares identical items with another.
   * This is different to checking for equality using equal-signs, because
   * the collections may be different objects, but contain the same data.
   *
   * @param collection - Collection to compare with
   * @returns Whether the collections have identical contents
   */ equals(collection) {
        if (!collection) return false;
        if (this === collection) return true;
        if (this.size !== collection.size) return false;
        for (const [key, value] of this){
            if (!collection.has(key) || value !== collection.get(key)) {
                return false;
            }
        }
        return true;
    }
    /**
   * The sort method sorts the items of a collection in place and returns it.
   * The sort is not necessarily stable in Node 10 or older.
   * The default sort order is according to string Unicode code points.
   *
   * @param compareFunction - Specifies a function that defines the sort order.
   * If omitted, the collection is sorted according to each character's Unicode code point value, according to the string conversion of each element.
   * @example
   * ```ts
   * collection.sort((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
   * ```
   */ sort(compareFunction = _Collection.defaultSort) {
        const entries = [
            ...this.entries()
        ];
        entries.sort((a, b)=>compareFunction(a[1], b[1], a[0], b[0]));
        super.clear();
        for (const [key, value] of entries){
            super.set(key, value);
        }
        return this;
    }
    /**
   * The intersection method returns a new collection containing the items where the key is present in both collections.
   *
   * @param other - The other Collection to filter against
   * @example
   * ```ts
   * const col1 = new Collection([['a', 1], ['b', 2]]);
   * const col2 = new Collection([['a', 1], ['c', 3]]);
   * const intersection = col1.intersection(col2);
   * console.log(col1.intersection(col2));
   * // => Collection { 'a' => 1 }
   * ```
   */ intersection(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this){
            if (other.has(key)) coll.set(key, value);
        }
        return coll;
    }
    /**
   * Returns a new collection containing the items where the key is present in either of the collections.
   *
   * @remarks
   *
   * If the collections have any items with the same key, the value from the first collection will be used.
   * @param other - The other Collection to filter against
   * @example
   * ```ts
   * const col1 = new Collection([['a', 1], ['b', 2]]);
   * const col2 = new Collection([['a', 1], ['b', 3], ['c', 3]]);
   * const union = col1.union(col2);
   * console.log(union);
   * // => Collection { 'a' => 1, 'b' => 2, 'c' => 3 }
   * ```
   */ union(other) {
        const coll = new this.constructor[Symbol.species](this);
        for (const [key, value] of other){
            if (!coll.has(key)) coll.set(key, value);
        }
        return coll;
    }
    /**
   * Returns a new collection containing the items where the key is present in this collection but not the other.
   *
   * @param other - The other Collection to filter against
   * @example
   * ```ts
   * const col1 = new Collection([['a', 1], ['b', 2]]);
   * const col2 = new Collection([['a', 1], ['c', 3]]);
   * console.log(col1.difference(col2));
   * // => Collection { 'b' => 2 }
   * console.log(col2.difference(col1));
   * // => Collection { 'c' => 3 }
   * ```
   */ difference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this){
            if (!other.has(key)) coll.set(key, value);
        }
        return coll;
    }
    /**
   * Returns a new collection containing only the items where the keys are present in either collection, but not both.
   *
   * @param other - The other Collection to filter against
   * @example
   * ```ts
   * const col1 = new Collection([['a', 1], ['b', 2]]);
   * const col2 = new Collection([['a', 1], ['c', 3]]);
   * const symmetricDifference = col1.symmetricDifference(col2);
   * console.log(col1.symmetricDifference(col2));
   * // => Collection { 'b' => 2, 'c' => 3 }
   * ```
   */ symmetricDifference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [key, value] of this){
            if (!other.has(key)) coll.set(key, value);
        }
        for (const [key, value] of other){
            if (!this.has(key)) coll.set(key, value);
        }
        return coll;
    }
    /**
   * Merges two Collections together into a new Collection.
   *
   * @param other - The other Collection to merge with
   * @param whenInSelf - Function getting the result if the entry only exists in this Collection
   * @param whenInOther - Function getting the result if the entry only exists in the other Collection
   * @param whenInBoth - Function getting the result if the entry exists in both Collections
   * @example
   * ```ts
   * // Sums up the entries in two collections.
   * coll.merge(
   *  other,
   *  x => ({ keep: true, value: x }),
   *  y => ({ keep: true, value: y }),
   *  (x, y) => ({ keep: true, value: x + y }),
   * );
   * ```
   * @example
   * ```ts
   * // Intersects two collections in a left-biased manner.
   * coll.merge(
   *  other,
   *  x => ({ keep: false }),
   *  y => ({ keep: false }),
   *  (x, _) => ({ keep: true, value: x }),
   * );
   * ```
   */ merge(other, whenInSelf, whenInOther, whenInBoth) {
        const coll = new this.constructor[Symbol.species]();
        const keys = /* @__PURE__ */ new Set([
            ...this.keys(),
            ...other.keys()
        ]);
        for (const key of keys){
            const hasInSelf = this.has(key);
            const hasInOther = other.has(key);
            if (hasInSelf && hasInOther) {
                const result = whenInBoth(this.get(key), other.get(key), key);
                if (result.keep) coll.set(key, result.value);
            } else if (hasInSelf) {
                const result = whenInSelf(this.get(key), key);
                if (result.keep) coll.set(key, result.value);
            } else if (hasInOther) {
                const result = whenInOther(other.get(key), key);
                if (result.keep) coll.set(key, result.value);
            }
        }
        return coll;
    }
    /**
   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed | Array.toReversed()}
   * but returns a Collection instead of an Array.
   */ toReversed() {
        return new this.constructor[Symbol.species](this).reverse();
    }
    /**
   * The sorted method sorts the items of a collection and returns it.
   * The sort is not necessarily stable in Node 10 or older.
   * The default sort order is according to string Unicode code points.
   *
   * @param compareFunction - Specifies a function that defines the sort order.
   * If omitted, the collection is sorted according to each character's Unicode code point value,
   * according to the string conversion of each element.
   * @example
   * ```ts
   * collection.sorted((userA, userB) => userA.createdTimestamp - userB.createdTimestamp);
   * ```
   */ toSorted(compareFunction = _Collection.defaultSort) {
        return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk)=>compareFunction(av, bv, ak, bk));
    }
    toJSON() {
        return [
            ...this.entries()
        ];
    }
    static defaultSort(firstValue, secondValue) {
        return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    /**
   * Creates a Collection from a list of entries.
   *
   * @param entries - The list of entries
   * @param combine - Function to combine an existing entry with a new one
   * @example
   * ```ts
   * Collection.combineEntries([["a", 1], ["b", 2], ["a", 2]], (x, y) => x + y);
   * // returns Collection { "a" => 3, "b" => 2 }
   * ```
   */ static combineEntries(entries, combine) {
        const coll = new _Collection();
        for (const [key, value] of entries){
            if (coll.has(key)) {
                coll.set(key, combine(coll.get(key), value, key));
            } else {
                coll.set(key, value);
            }
        }
        return coll;
    }
};
// src/index.ts
var version = "2.1.1";
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@sapphire/snowflake/dist/esm/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "DiscordSnowflake": ()=>DiscordSnowflake,
    "MaximumIncrement": ()=>MaximumIncrement,
    "MaximumProcessId": ()=>MaximumProcessId,
    "MaximumWorkerId": ()=>MaximumWorkerId,
    "Snowflake": ()=>Snowflake,
    "TwitterSnowflake": ()=>TwitterSnowflake
});
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
var __publicField = (obj, key, value)=>{
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
};
// src/lib/Snowflake.ts
var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
var MaximumWorkerId = 0b11111n;
var MaximumProcessId = 0b11111n;
var MaximumIncrement = 0b111111111111n;
var _a, _b, _c, _d;
var _Snowflake = class _Snowflake {
    /**
   * @param epoch the epoch to use
   */ constructor(epoch){
        /**
     * Alias for {@link deconstruct}
     */ // eslint-disable-next-line @typescript-eslint/unbound-method
        __publicField(this, "decode", this.deconstruct);
        /**
     * Internal reference of the epoch passed in the constructor
     * @internal
     */ __publicField(this, _a);
        /**
     * Internal incrementor for generating snowflakes
     * @internal
     */ __publicField(this, _b, 0n);
        /**
     * The process ID that will be used by default in the generate method
     * @internal
     */ __publicField(this, _c, 1n);
        /**
     * The worker ID that will be used by default in the generate method
     * @internal
     */ __publicField(this, _d, 0n);
        this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    }
    /**
   * The epoch for this snowflake
   */ get epoch() {
        return this[EpochSymbol];
    }
    /**
   * Gets the configured process ID
   */ get processId() {
        return this[ProcessIdSymbol];
    }
    /**
   * Sets the process ID that will be used by default for the {@link generate} method
   * @param value The new value, will be coerced to BigInt and masked with `0b11111n`
   */ set processId(value) {
        this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
    }
    /**
   * Gets the configured worker ID
   */ get workerId() {
        return this[WorkerIdSymbol];
    }
    /**
   * Sets the worker ID that will be used by default for the {@link generate} method
   * @param value The new value, will be coerced to BigInt and masked with `0b11111n`
   */ set workerId(value) {
        this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
    }
    /**
   * Generates a snowflake given an epoch and optionally a timestamp
   * @param options options to pass into the generator, see {@link SnowflakeGenerateOptions}
   *
   * **note** when `increment` is not provided it defaults to the private `increment` of the instance
   * @example
   * ```typescript
   * const epoch = new Date('2000-01-01T00:00:00.000Z');
   * const snowflake = new Snowflake(epoch).generate();
   * ```
   * @returns A unique snowflake
   */ generate({ increment, timestamp = Date.now(), workerId = this[WorkerIdSymbol], processId = this[ProcessIdSymbol] } = {}) {
        if (timestamp instanceof Date) timestamp = BigInt(timestamp.getTime());
        else if (typeof timestamp === "number") timestamp = BigInt(timestamp);
        else if (typeof timestamp !== "bigint") {
            throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
        }
        if (typeof increment !== "bigint") {
            increment = this[IncrementSymbol];
            this[IncrementSymbol] = increment + 1n & MaximumIncrement;
        }
        return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
    }
    /**
   * Deconstructs a snowflake given a snowflake ID
   * @param id the snowflake to deconstruct
   * @returns a deconstructed snowflake
   * @example
   * ```typescript
   * const epoch = new Date('2000-01-01T00:00:00.000Z');
   * const snowflake = new Snowflake(epoch).deconstruct('3971046231244935168');
   * ```
   */ deconstruct(id) {
        const bigIntId = BigInt(id);
        const epoch = this[EpochSymbol];
        return {
            id: bigIntId,
            timestamp: (bigIntId >> 22n) + epoch,
            workerId: bigIntId >> 17n & MaximumWorkerId,
            processId: bigIntId >> 12n & MaximumProcessId,
            increment: bigIntId & MaximumIncrement,
            epoch
        };
    }
    /**
   * Retrieves the timestamp field's value from a snowflake.
   * @param id The snowflake to get the timestamp value from.
   * @returns The UNIX timestamp that is stored in `id`.
   */ timestampFrom(id) {
        return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
    }
    /**
   * Returns a number indicating whether a reference snowflake comes before, or after, or is same as the given
   * snowflake in sort order.
   * @param a The first snowflake to compare.
   * @param b The second snowflake to compare.
   * @returns `-1` if `a` is older than `b`, `0` if `a` and `b` are equals, `1` if `a` is newer than `b`.
   * @example Sort snowflakes in ascending order
   * ```typescript
   * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];
   * console.log(ids.sort((a, b) => Snowflake.compare(a, b)));
   * //  ['254360814063058944', '737141877803057244', '1056191128120082432'];
   * ```
   * @example Sort snowflakes in descending order
   * ```typescript
   * const ids = ['737141877803057244', '1056191128120082432', '254360814063058944'];
   * console.log(ids.sort((a, b) => -Snowflake.compare(a, b)));
   * //  ['1056191128120082432', '737141877803057244', '254360814063058944'];
   * ```
   */ static compare(a, b) {
        const typeA = typeof a;
        return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
    }
};
_a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
__name(_Snowflake, "Snowflake");
var Snowflake = _Snowflake;
function cmpBigInt(a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
}
__name(cmpBigInt, "cmpBigInt");
function cmpString(a, b) {
    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
}
__name(cmpString, "cmpString");
// src/lib/DiscordSnowflake.ts
var DiscordSnowflake = new Snowflake(1420070400000n);
// src/lib/TwitterSnowflake.ts
var TwitterSnowflake = new Snowflake(1288834974657n);
;
 //# sourceMappingURL=out.js.map
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@vladfrangu/async_event_emitter/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AbortError": ()=>AbortError,
    "AsyncEventEmitter": ()=>AsyncEventEmitter
});
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
// src/index.ts
function validateListener(input) {
    if (typeof input !== "function") {
        throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
    }
}
__name(validateListener, "validateListener");
function validateAbortSignal(input) {
    if (input && !(input instanceof AbortSignal)) {
        throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
    }
}
__name(validateAbortSignal, "validateAbortSignal");
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++){
        list[index] = list[index + 1];
    }
    list.pop();
}
__name(spliceOne, "spliceOne");
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
__name(arrayClone, "arrayClone");
function identicalSequenceRange(a, b) {
    for(let i = 0; i < a.length - 3; i++){
        const pos = b.indexOf(a[i]);
        if (pos !== -1) {
            const rest = b.length - pos;
            if (rest > 3) {
                let len = 1;
                const maxLen = Math.min(a.length - i, rest);
                while(maxLen > len && a[i + len] === b[pos + len]){
                    len++;
                }
                if (len > 3) {
                    return [
                        len,
                        i
                    ];
                }
            }
        }
    }
    return [
        0,
        0
    ];
}
__name(identicalSequenceRange, "identicalSequenceRange");
function enhanceStackTrace(err, own) {
    let ctorInfo = "";
    try {
        const { name } = this.constructor;
        if (name !== "AsyncEventEmitter") ctorInfo = ` on ${name} instance`;
    } catch  {}
    const sep = `
Emitted 'error' event${ctorInfo} at:
`;
    const errStack = err.stack.split("\n").slice(1);
    const ownStack = own.stack.split("\n").slice(1);
    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
    if (len > 0) {
        ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
    }
    return err.stack + sep + ownStack.join("\n");
}
__name(enhanceStackTrace, "enhanceStackTrace");
var brandSymbol = Symbol.for("async-event-emitter.ts-brand");
brandSymbol;
var _AsyncEventEmitter = class _AsyncEventEmitter {
    constructor(){
        this._events = {
            __proto__: null
        };
        this._eventCount = 0;
        this._maxListeners = 10;
        this._internalPromiseMap = /* @__PURE__ */ new Map();
        this._wrapperId = 0n;
    }
    addListener(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, false);
        this._addListener(eventName, wrapped, false);
        return this;
    }
    on(eventName, listener) {
        return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, true);
        this._addListener(eventName, wrapped, false);
        return this;
    }
    removeListener(eventName, listener) {
        validateListener(listener);
        const events = this._events;
        const eventList = events[eventName];
        if (eventList === void 0) {
            return this;
        }
        if (eventList === listener || eventList.listener === listener) {
            if (--this._eventCount === 0) {
                this._events = {
                    __proto__: null
                };
            } else {
                delete events[eventName];
                if (events.removeListener) {
                    this.emit("removeListener", eventName, eventList.listener ?? eventList);
                }
            }
        } else if (typeof eventList !== "function") {
            let position = -1;
            for(let i = eventList.length - 1; i >= 0; i--){
                if (eventList[i] === listener || eventList[i].listener === listener) {
                    position = i;
                    break;
                }
            }
            if (position < 0) {
                return this;
            }
            if (position === 0) {
                eventList.shift();
            } else {
                spliceOne(eventList, position);
            }
            if (eventList.length === 0) {
                delete events[eventName];
                --this._eventCount;
            }
            if (events.removeListener !== void 0) {
                this.emit("removeListener", eventName, listener);
            }
        }
        return this;
    }
    off(eventName, listener) {
        return this.removeListener(eventName, listener);
    }
    removeAllListeners(event) {
        const events = this._events;
        if (events.removeListener === void 0) {
            if (!event) {
                this._events = {
                    __proto__: null
                };
                this._eventCount = 0;
            } else if (events[event] !== void 0) {
                if (--this._eventCount === 0) {
                    this._events = {
                        __proto__: null
                    };
                } else {
                    delete events[event];
                }
            }
            return this;
        }
        if (!event) {
            for (const key of Reflect.ownKeys(events)){
                if (key === "removeListener") {
                    continue;
                }
                this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = {
                __proto__: null
            };
            this._eventCount = 0;
            return this;
        }
        const listeners = events[event];
        if (typeof listeners === "function") {
            this.removeListener(event, listeners);
        } else if (listeners !== void 0) {
            for(let i = listeners.length - 1; i >= 0; i--){
                this.removeListener(event, listeners[i]);
            }
        }
        return this;
    }
    setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
            throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
        }
        this._maxListeners = n;
        return this;
    }
    getMaxListeners() {
        return this._maxListeners;
    }
    listeners(eventName) {
        const eventList = this._events[eventName];
        if (eventList === void 0) {
            return [];
        }
        if (typeof eventList === "function") {
            return [
                eventList.listener ?? eventList
            ];
        }
        const ret = arrayClone(eventList);
        for(let i = 0; i < ret.length; ++i){
            const orig = ret[i].listener;
            if (typeof orig === "function") {
                ret[i] = orig;
            }
        }
        return ret;
    }
    rawListeners(eventName) {
        const eventList = this._events[eventName];
        if (eventList === void 0) {
            return [];
        }
        if (typeof eventList === "function") {
            return [
                eventList
            ];
        }
        return arrayClone(eventList);
    }
    emit(eventName, ...args) {
        let doError = eventName === "error";
        const events = this._events;
        if (events !== void 0) {
            doError = doError && events.error === void 0;
        } else if (!doError) {
            return false;
        }
        if (doError) {
            let er;
            if (args.length > 0) {
                er = args[0];
            }
            if (er instanceof Error) {
                try {
                    const capture = {};
                    Error.captureStackTrace(capture, _AsyncEventEmitter.prototype.emit);
                    Object.defineProperty(er, "stack", {
                        value: enhanceStackTrace.call(this, er, capture),
                        configurable: true
                    });
                } catch  {}
                throw er; // Unhandled 'error' event
            }
            const stringifiedError = String(er);
            const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
            err.context = er;
            throw err; // Unhandled 'error' event
        }
        const handlers = events[eventName];
        if (handlers === void 0) {
            return false;
        }
        if (typeof handlers === "function") {
            const result = handlers.apply(this, args);
            if (result !== void 0 && result !== null) {
                handleMaybeAsync(this, result);
            }
        } else {
            const len = handlers.length;
            const listeners = arrayClone(handlers);
            for(let i = 0; i < len; ++i){
                const result = listeners[i].apply(this, args);
                if (result !== void 0 && result !== null) {
                    handleMaybeAsync(this, result);
                }
            }
        }
        return true;
    }
    listenerCount(eventName) {
        const events = this._events;
        if (events === void 0) {
            return 0;
        }
        const eventListeners = events[eventName];
        if (typeof eventListeners === "function") {
            return 1;
        }
        return eventListeners?.length ?? 0;
    }
    prependListener(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, false);
        this._addListener(eventName, wrapped, true);
        return this;
    }
    prependOnceListener(eventName, listener) {
        validateListener(listener);
        const wrapped = this._wrapListener(eventName, listener, true);
        this._addListener(eventName, wrapped, true);
        return this;
    }
    eventNames() {
        return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
    }
    async waitForAllListenersToComplete() {
        const promises = [
            ...this._internalPromiseMap.values()
        ];
        if (promises.length === 0) {
            return false;
        }
        await Promise.all(promises);
        return true;
    }
    _addListener(eventName, wrappedListener, prepend) {
        if (this._events.newListener !== void 0) {
            this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
        }
        let existing = this._events[eventName];
        if (existing === void 0) {
            existing = this._events[eventName] = wrappedListener;
            ++this._eventCount;
        } else if (typeof existing === "function") {
            existing = this._events[eventName] = prepend ? [
                wrappedListener,
                existing
            ] : [
                existing,
                wrappedListener
            ];
        } else if (prepend) {
            existing.unshift(wrappedListener);
        } else {
            existing.push(wrappedListener);
        }
        const existingWarnedAboutMaxListeners = Reflect.get(existing, "_hasWarnedAboutMaxListeners");
        if (this._maxListeners > 0 && existing.length > this._maxListeners && !existingWarnedAboutMaxListeners) {
            Reflect.set(existing, "_hasWarnedAboutMaxListeners", true);
            const warningMessage = [
                `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
                `Use emitter.setMaxListeners() to increase the limit.`
            ].join(" ");
            console.warn(warningMessage);
        }
    }
    _wrapListener(eventName, listener, once) {
        if (!once) {
            return listener;
        }
        const state = {
            fired: false,
            wrapFn: void 0,
            eventEmitter: this,
            eventName,
            listener
        };
        const aliased = onceWrapper;
        const wrapped = aliased.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
    }
    static listenerCount(emitter, eventName) {
        return emitter.listenerCount(eventName);
    }
    static async once(emitter, eventName, options = {}) {
        const signal = options?.signal;
        validateAbortSignal(signal);
        if (signal?.aborted) {
            throw new AbortError(void 0, {
                cause: getReason(signal)
            });
        }
        return new Promise((resolve, reject)=>{
            const errorListener = /* @__PURE__ */ __name((err)=>{
                emitter.removeListener(eventName, resolver);
                if (signal) {
                    eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
                }
                reject(err);
            }, "errorListener");
            const resolver = /* @__PURE__ */ __name((...args)=>{
                emitter.removeListener("error", errorListener);
                if (signal) {
                    eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
                }
                resolve(args);
            }, "resolver");
            emitter.once(eventName, resolver);
            if (eventName !== "error") {
                emitter.once("error", errorListener);
            }
            const abortListener = /* @__PURE__ */ __name(()=>{
                eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
                eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
                reject(new AbortError(void 0, {
                    cause: getReason(signal)
                }));
            }, "abortListener");
            if (signal) {
                eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                    once: true
                });
            }
        });
    }
    static on(emitter, eventName, options = {}) {
        const signal = options?.signal;
        validateAbortSignal(signal);
        if (signal?.aborted) {
            throw new AbortError(void 0, {
                cause: getReason(signal)
            });
        }
        const unconsumedEvents = [];
        const unconsumedPromises = [];
        let error = null;
        let finished = false;
        const abortListener = /* @__PURE__ */ __name(()=>{
            errorHandler(new AbortError(void 0, {
                cause: getReason(signal)
            }));
        }, "abortListener");
        const eventHandler = /* @__PURE__ */ __name((...args)=>{
            const promise = unconsumedPromises.shift();
            if (promise) {
                promise.resolve(createIterResult(args, false));
            } else {
                unconsumedEvents.push(args);
            }
        }, "eventHandler");
        const errorHandler = /* @__PURE__ */ __name((err)=>{
            finished = true;
            const toError = unconsumedPromises.shift();
            if (toError) {
                toError.reject(err);
            } else {
                error = err;
            }
            void iterator.return();
        }, "errorHandler");
        const iterator = Object.setPrototypeOf({
            next () {
                const value = unconsumedEvents.shift();
                if (value) {
                    return Promise.resolve(createIterResult(value, false));
                }
                if (error) {
                    const p = Promise.reject(error);
                    error = null;
                    return p;
                }
                if (finished) {
                    return Promise.resolve(createIterResult(void 0, true));
                }
                return new Promise((resolve, reject)=>{
                    unconsumedPromises.push({
                        resolve,
                        reject
                    });
                });
            },
            return () {
                emitter.off(eventName, eventHandler);
                emitter.off("error", errorHandler);
                if (signal) {
                    eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
                }
                finished = true;
                const doneResult = createIterResult(void 0, true);
                for (const promise of unconsumedPromises){
                    promise.resolve(doneResult);
                }
                return Promise.resolve(doneResult);
            },
            throw (err) {
                if (!err || !(err instanceof Error)) {
                    throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
                }
                error = err;
                emitter.off(eventName, eventHandler);
                emitter.off("error", errorHandler);
            },
            [Symbol.asyncIterator] () {
                return this;
            }
        }, AsyncIteratorPrototype);
        emitter.on(eventName, eventHandler);
        if (eventName !== "error") {
            emitter.on("error", errorHandler);
        }
        if (signal) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener);
        }
        return iterator;
    }
};
__name(_AsyncEventEmitter, "AsyncEventEmitter");
var AsyncEventEmitter = _AsyncEventEmitter;
function onceWrapper() {
    if (!this.fired) {
        this.eventEmitter.removeListener(this.eventName, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.eventEmitter);
        }
        return this.listener.apply(this.eventEmitter, arguments);
    }
}
__name(onceWrapper, "onceWrapper");
function getReason(signal) {
    return signal?.reason;
}
__name(getReason, "getReason");
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.off === "function") {
        emitter.off(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    }
}
__name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, listener, flags);
    }
}
__name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
__name(createIterResult, "createIterResult");
var _AbortError = class _AbortError extends Error {
    constructor(message = "The operation was aborted", options = void 0){
        if (options !== void 0 && typeof options !== "object") {
            throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
};
__name(_AbortError, "AbortError");
var AbortError = _AbortError;
function handleMaybeAsync(emitter, result) {
    try {
        const the = result.then;
        const fin = result.finally;
        if (typeof the === "function") {
            the.call(result, void 0, (error)=>{
                setTimeout(()=>{
                    emitter.emit("error", error);
                }, 0);
            });
        }
        if (typeof fin === "function") {
            const promiseId = String(++emitter["_wrapperId"]);
            emitter["_internalPromiseMap"].set(promiseId, result);
            fin.call(result, /* @__PURE__ */ __name(function final() {
                emitter["_internalPromiseMap"].delete(promiseId);
            }, "final"));
        }
    } catch (err) {
        emitter.emit("error", err);
    }
}
__name(handleMaybeAsync, "handleMaybeAsync");
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/magic-bytes.js/dist/model/toHex.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromHex = exports.toHex = void 0;
const hex = (num)=>new Number(num).toString(16).toLowerCase();
const toHex = (num)=>`0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
exports.toHex = toHex;
const fromHex = (hex)=>new Number(hex);
exports.fromHex = fromHex;
}}),
"[project]/node_modules/magic-bytes.js/dist/model/tree.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createComplexNode = exports.createNode = exports.merge = void 0;
const createMatch = (leaf)=>({
        typename: leaf.typename,
        mime: leaf.info.mime,
        extension: leaf.info.extension
    });
const isLeafNode = (tree, path)=>tree && path.length === 0;
const merge = (node, tree)=>{
    if (node.bytes.length === 0) return tree;
    const [currentByte, ...path] = node.bytes;
    const currentTree = tree.bytes[currentByte];
    // traversed to end. Just add key to leaf.
    if (isLeafNode(currentTree, path)) {
        const matchingNode = tree.bytes[currentByte];
        tree.bytes[currentByte] = {
            ...matchingNode,
            matches: [
                ...matchingNode.matches ?? [],
                createMatch(node)
            ]
        };
        return tree;
    }
    // Path exists already, Merge subtree
    if (tree.bytes[currentByte]) {
        tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
    } else {
        tree.bytes[currentByte] = exports.createComplexNode(node.typename, path, node.info);
    }
    return tree;
};
exports.merge = merge;
const createNode = (typename, bytes, info)=>{
    return {
        typename,
        bytes,
        info: info ? info : {}
    };
};
exports.createNode = createNode;
const createComplexNode = (typename, bytes, info)=>{
    let obj = {
        bytes: {},
        matches: undefined
    };
    const [currentKey, ...path] = bytes;
    if (bytes.length === 0) {
        return {
            matches: [
                createMatch({
                    typename: typename,
                    info: info ? {
                        extension: info.extension,
                        mime: info.mime
                    } : {}
                })
            ],
            bytes: {}
        };
    }
    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);
    return obj;
};
exports.createComplexNode = createComplexNode;
}}),
"[project]/node_modules/magic-bytes.js/dist/model/pattern-tree.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createTree = exports.add = void 0;
const toHex_1 = __turbopack_context__.r("[project]/node_modules/magic-bytes.js/dist/model/toHex.js [app-route] (ecmascript)");
const tree_1 = __turbopack_context__.r("[project]/node_modules/magic-bytes.js/dist/model/tree.js [app-route] (ecmascript)");
// https://en.wikipedia.org/wiki/List_of_file_signatures
let tree = {
    noOffset: null,
    offset: {}
};
const add = (typename, signature, additionalInfo, offset)=>{
    if (offset) {
        const existing = tree.offset[toHex_1.toHex(offset)];
        if (!existing) {
            tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e)=>e.toLowerCase()), additionalInfo);
        } else {
            const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e)=>e.toLowerCase()), additionalInfo), {
                ...existing
            });
            tree.offset[toHex_1.toHex(offset)] = merged;
        }
    } else {
        if (tree.noOffset === null) {
            tree.noOffset = tree_1.createComplexNode(typename, signature.map((e)=>e.toLowerCase()), additionalInfo);
        } else {
            tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e)=>e.toLowerCase()), additionalInfo), tree.noOffset);
        }
    }
};
exports.add = add;
exports.add("gif", [
    "0x47",
    "0x49",
    "0x46",
    "0x38",
    "0x37",
    "0x61"
], {
    mime: "image/gif",
    extension: "gif"
});
exports.add("gif", [
    "0x47",
    "0x49",
    "0x46",
    "0x38",
    "0x39",
    "0x61"
], {
    mime: "image/gif",
    extension: "gif"
});
exports.add("jpg", [
    "0xFF",
    "0xD8",
    "0xFF"
], {
    mime: "image/jpeg",
    extension: "jpeg"
});
exports.add("webp", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x45",
    "0x42",
    "0x50"
], {
    mime: "image/webp",
    extension: "webp"
});
exports.add("heif", [
    "0x66",
    "0x74",
    "0x79",
    "0x70",
    "0x6D",
    "0x69",
    "0x66",
    "0x31"
], {
    mime: "image/heif",
    extension: "heif"
}, 4);
exports.add("heif", [
    "0x66",
    "0x74",
    "0x79",
    "0x70",
    "0x68",
    "0x65",
    "0x69",
    "0x63"
], {
    mime: "image/heif",
    extension: "heic"
}, 4);
exports.add("rpm", [
    "0xed",
    "0xab",
    "0xee",
    "0xdb"
]);
exports.add("bin", [
    "0x53",
    "0x50",
    "0x30",
    "0x31"
], {
    mime: "application/octet-stream",
    extension: "bin"
});
exports.add("pic", [
    "0x00"
]);
exports.add("pif", [
    "0x00"
]);
exports.add("sea", [
    "0x00"
]);
exports.add("ytr", [
    "0x00"
]);
// 66747970
// 6D703432
exports.add("mp4", [
    "0x66",
    "0x74",
    "0x79",
    "0x70"
], {
    mime: "video/mp4",
    extension: "mp4"
}, 0x4);
exports.add("ttf", [
    "0x00",
    "0x01",
    "0x00",
    "0x00",
    "0x00"
], {
    mime: "font/ttf",
    extension: "ttf"
});
exports.add("otf", [
    "0x4F",
    "0x54",
    "0x54",
    "0x4F"
], {
    mime: "font/otf",
    extension: "otf"
});
exports.add("eot", [
    "0x50",
    "0x4C"
], {
    mime: "application/vnd.ms-fontobject",
    extension: "eot"
});
exports.add("woff", [
    "0x77",
    "0x4F",
    "0x46",
    "0x46"
], {
    mime: "font/woff",
    extension: "woff"
});
exports.add("woff2", [
    "0x77",
    "0x4F",
    "0x46",
    "0x32"
], {
    mime: "font/woff2",
    extension: "woff2"
});
exports.add("pdb", [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
]);
exports.add("dba", [
    "0xBE",
    "0xBA",
    "0xFE",
    "0xCA"
]);
exports.add("dba2", [
    "0x00",
    "0x01",
    "0x42",
    "0x44"
]);
exports.add("tda", [
    "0x00",
    "0x01",
    "0x44",
    "0x54"
]);
exports.add("tda2", [
    "0x00",
    "0x01",
    "0x00",
    "0x00"
]);
exports.add("ico", [
    "0x00",
    "0x00",
    "0x01",
    "0x00"
], {
    mime: "image/x-icon",
    extension: "ico"
});
exports.add("3gp", [
    "0x66",
    "0x74",
    "0x79",
    "0x70",
    "0x33",
    "0x67"
]);
exports.add("z", [
    "0x1F",
    "0x9D"
]);
exports.add("tar.z", [
    "0x1F",
    "0xA0"
]);
exports.add("bac", [
    "0x42",
    "0x41",
    "0x43",
    "0x4B",
    "0x4D",
    "0x49",
    "0x4B",
    "0x45",
    "0x44",
    "0x49",
    "0x53",
    "0x4B"
]);
exports.add("bz2", [
    "0x42",
    "0x5A",
    "0x68"
], {
    mime: "application/x-bzip2",
    extension: "bz2"
});
exports.add("tif", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00"
], {
    mime: "image/tiff",
    extension: "tif"
});
exports.add("tiff", [
    "0x4D",
    "0x4D",
    "0x00",
    "0x2A"
], {
    mime: "image/tiff",
    extension: "tiff"
});
exports.add("cr2", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00",
    "0x10",
    "0x00",
    "0x00",
    "0x00",
    "0x43",
    "0x52"
]);
exports.add("cin", [
    "0x80",
    "0x2A",
    "0x5F",
    "0xD7"
]);
exports.add("cin1", [
    "0x52",
    "0x4E",
    "0x43",
    "0x01"
]);
exports.add("cin2", [
    "0x52",
    "0x4E",
    "0x43",
    "0x02"
]);
exports.add("dpx", [
    "0x53",
    "0x44",
    "0x50",
    "0x58"
]);
exports.add("dpx2", [
    "0x58",
    "0x50",
    "0x44",
    "0x53"
]);
exports.add("exr", [
    "0x76",
    "0x2F",
    "0x31",
    "0x01"
]);
exports.add("bpg", [
    "0x42",
    "0x50",
    "0x47",
    "0xFB"
]);
exports.add("ilbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x49",
    "0x4C",
    "0x42",
    "0x4D"
]);
exports.add("8svx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x38",
    "0x53",
    "0x56",
    "0x58"
]);
exports.add("acbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x43",
    "0x42",
    "0x4D"
]);
exports.add("anbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x42",
    "0x4D"
]);
exports.add("anim", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x49",
    "0x4D"
]);
exports.add("faxx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x58",
    "0x58"
]);
exports.add("ftxt", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x54",
    "0x58",
    "0x54"
]);
exports.add("smus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x4D",
    "0x55",
    "0x53"
]);
exports.add("cmus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x43",
    "0x4D",
    "0x55",
    "0x53"
]);
exports.add("yuvn", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x59",
    "0x55",
    "0x56",
    "0x4E"
]);
exports.add("iff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x4E",
    "0x54"
]);
exports.add("aiff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x49",
    "0x46",
    "0x46"
], {
    mime: "audio/x-aiff",
    extension: "aiff"
});
exports.add("idx", [
    "0x49",
    "0x4E",
    "0x44",
    "0x58"
]);
exports.add("lz", [
    "0x4C",
    "0x5A",
    "0x49",
    "0x50"
]);
exports.add("exe", [
    "0x4D",
    "0x5A"
]);
exports.add("zip", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/zip",
    extension: "zip"
});
exports.add("zip", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/zip",
    extension: "zip"
});
exports.add("zip", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/zip",
    extension: "zip"
});
exports.add("jar", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/java-archive",
    extension: "jar"
});
exports.add("jar", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/java-archive",
    extension: "jar"
});
exports.add("jar", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/java-archive",
    extension: "jar"
});
exports.add("odt", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
});
exports.add("odt", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
});
exports.add("odt", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
});
exports.add("ods", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
});
exports.add("ods", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
});
exports.add("ods", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
});
exports.add("odp", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
});
exports.add("odp", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
});
exports.add("odp", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
});
exports.add("docx", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
});
exports.add("docx", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
});
exports.add("docx", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
});
exports.add("xlsx", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
});
exports.add("xlsx", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
});
exports.add("xlsx", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
});
exports.add("pptx", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
});
exports.add("pptx", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
});
exports.add("pptx", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
});
exports.add("vsdx", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
});
exports.add("vsdx", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
});
exports.add("vsdx", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.ms-visio.drawing",
    extension: "vsdx"
});
exports.add("apk", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
});
exports.add("apk", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
});
exports.add("apk", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.android.package-archive",
    extension: "apk"
});
exports.add("aar", [
    "0x50",
    "0x4B",
    "0x03",
    "0x04"
], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
});
exports.add("aar", [
    "0x50",
    "0x4B",
    "0x05",
    "0x06"
], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
});
exports.add("aar", [
    "0x50",
    "0x4B",
    "0x07",
    "0x08"
], {
    mime: "application/vnd.android.package-archive",
    extension: "aar"
});
exports.add("rar", [
    "0x52",
    "0x61",
    "0x72",
    "0x21",
    "0x1A",
    "0x07",
    "0x00"
], {
    mime: "application/vnd.rar",
    extension: "rar"
});
exports.add("rar", [
    "0x52",
    "0x61",
    "0x72",
    "0x21",
    "0x1A",
    "0x07",
    "0x01",
    "0x00"
], {
    mime: "application/vnd.rar",
    extension: "rar"
});
exports.add("rar", [
    "0x7F",
    "0x45",
    "0x4C",
    "0x46"
], {
    mime: "application/vnd.rar",
    extension: "rar"
});
exports.add("png", [
    "0x89",
    "0x50",
    "0x4E",
    "0x47",
    "0x0D",
    "0x0A",
    "0x1A",
    "0x0A"
], {
    mime: "image/png",
    extension: "png"
});
exports.add("apng", [
    "0x89",
    "0x50",
    "0x4E",
    "0x47",
    "0x0D",
    "0x0A",
    "0x1A",
    "0x0A"
], {
    mime: "image/apng",
    extension: "apng"
});
exports.add("class", [
    "0xCA",
    "0xFE",
    "0xBA",
    "0xBE"
]);
exports.add("class", [
    "0xEF",
    "0xBB",
    "0xBF"
]);
exports.add("class", [
    "0xFE",
    "0xed",
    "0xFA",
    "0xCE"
], undefined, 0x1000);
exports.add("class", [
    "0xFE",
    "0xed",
    "0xFA",
    "0xCF"
], undefined, 0x1000);
exports.add("class", [
    "0xCE",
    "0xFA",
    "0xed",
    "0xFE"
]);
exports.add("class", [
    "0xCF",
    "0xFA",
    "0xed",
    "0xFE"
]);
exports.add("class", [
    "0xFF",
    "0xFE"
]);
exports.add("class", [
    "0xFF",
    "0xFE"
]);
exports.add("class", [
    "0xFF",
    "0xFE",
    "0x00",
    "0x00"
]);
exports.add("ps", [
    "0x25",
    "0x21",
    "0x50",
    "0x53"
], {
    mime: "application/postscript",
    extension: ".ps"
});
exports.add("pdf", [
    "0x25",
    "0x50",
    "0x44",
    "0x46"
], {
    mime: "application/pdf",
    extension: "pdf"
});
exports.add("asf", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
]);
exports.add("wma", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
]);
exports.add("wmv", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
]);
exports.add("deploymentimage", [
    "0x24",
    "0x53",
    "0x44",
    "0x49",
    "0x30",
    "0x30",
    "0x30",
    "0x31"
]);
// ogg video ' theora'
exports.add("ogv", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x80",
    "0x74",
    "0x68",
    "0x65",
    "0x6F",
    "0x72",
    "0x61"
], {
    mime: "video/ogg",
    extension: "ogv"
});
// ogg video '\x01video'
exports.add("ogm", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x69",
    "0x64",
    "0x65",
    "0x6F",
    "0x00"
], {
    mime: "video/ogg",
    extension: "ogm"
});
// ogg audio ' FLAC'
exports.add("oga", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x7F",
    "0x46",
    "0x4C",
    "0x41",
    "0x43"
], {
    mime: "audio/ogg",
    extension: "oga"
});
// ogg audio 'Speex  '
exports.add("spx", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x70",
    "0x65",
    "0x65",
    "0x78",
    "0x20",
    "0x20"
], {
    mime: "audio/ogg",
    extension: "spx"
});
// ogg audio '\x01vorbis '
exports.add("ogg", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "?",
    "0x01",
    "0x76",
    "0x6F",
    "0x72",
    "0x62",
    "0x69",
    "0x73"
], {
    mime: "audio/ogg",
    extension: "ogg"
});
// default OGG container
exports.add("ogx", [
    "0x4F",
    "0x67",
    "0x67",
    "0x53"
], {
    mime: "application/ogg",
    extension: "ogx"
});
exports.add("psd", [
    "0x38",
    "0x42",
    "0x50",
    "0x53"
], {
    mime: "application/x-photoshop",
    extension: "psd"
});
exports.add("clip", [
    "0x43",
    "0x53",
    "0x46",
    "0x43",
    "0x48",
    "0x55",
    "0x4e",
    "0x4b"
]);
exports.add("wav", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x41",
    "0x56",
    "0x45"
], {
    mime: "audio/x-wav",
    extension: "wav"
});
exports.add("avi", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x56",
    "0x49",
    "0x20"
], {
    mime: "video/x-msvideo",
    extension: "avi"
});
exports.add("mp3", [
    "0xFF",
    "0xFB"
], {
    mime: "audio/mpeg",
    extension: "mp3"
});
exports.add("mp3", [
    "0xFF",
    "0xF3"
], {
    mime: "audio/mpeg",
    extension: "mp3"
});
exports.add("mp3", [
    "0xFF",
    "0xF2"
], {
    mime: "audio/mpeg",
    extension: "mp3"
});
exports.add("mp3", [
    "0x49",
    "0x44",
    "0x33"
], {
    mime: "audio/mpeg",
    extension: "mp3"
});
exports.add("bmp", [
    "0x42",
    "0x4D"
], {
    mime: "image/bmp",
    extension: "bmp"
});
exports.add("iso", [
    "0x43",
    "0x44",
    "0x30",
    "0x30",
    "0x31"
]);
exports.add("flac", [
    "0x66",
    "0x4C",
    "0x61",
    "0x43"
]);
exports.add("mid", [
    "0x4D",
    "0x54",
    "0x68",
    "0x64"
], {
    mime: "audio/midi",
    extension: "mid"
});
exports.add("midi", [
    "0x4D",
    "0x54",
    "0x68",
    "0x64"
], {
    mime: "audio/midi",
    extension: "midi"
});
exports.add("doc", [
    "0xD0",
    "0xCF",
    "0x11",
    "0xE0",
    "0xA1",
    "0xB1",
    "0x1A",
    "0xE1"
], {
    mime: "application/msword",
    extension: "doc"
});
exports.add("xls", [
    "0xD0",
    "0xCF",
    "0x11",
    "0xE0",
    "0xA1",
    "0xB1",
    "0x1A",
    "0xE1"
], {
    mime: "application/vnd.ms-excel",
    extension: "xls"
});
exports.add("ppt", [
    "0xD0",
    "0xCF",
    "0x11",
    "0xE0",
    "0xA1",
    "0xB1",
    "0x1A",
    "0xE1"
], {
    mime: "application/vnd.ms-powerpoint",
    extension: "ppt"
});
exports.add("msg", [
    "0xD0",
    "0xCF",
    "0x11",
    "0xE0",
    "0xA1",
    "0xB1",
    "0x1A",
    "0xE1"
]);
exports.add("dex", [
    "0x64",
    "0x65",
    "0x78",
    "0x0A",
    "0x30",
    "0x33",
    "0x35",
    "0x00"
]);
exports.add("vmdk", [
    "0x4B",
    "0x44",
    "0x4D"
]);
exports.add("crx", [
    "0x43",
    "0x72",
    "0x32",
    "0x34"
]);
exports.add("fh8", [
    "0x41",
    "0x47",
    "0x44",
    "0x33"
]);
exports.add("cwk", [
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
]);
exports.add("cwk", [
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
]);
exports.add("toast", [
    "0x45",
    "0x52",
    "0x02",
    "0x00",
    "0x00",
    "0x00"
]);
exports.add("toast", [
    "0x8B",
    "0x45",
    "0x52",
    "0x02",
    "0x00",
    "0x00",
    "0x00"
]);
exports.add("dmg", [
    "0x78",
    "0x01",
    "0x73",
    "0x0D",
    "0x62",
    "0x62",
    "0x60"
]);
exports.add("xar", [
    "0x78",
    "0x61",
    "0x72",
    "0x21"
]);
exports.add("dat", [
    "0x50",
    "0x4D",
    "0x4F",
    "0x43",
    "0x43",
    "0x4D",
    "0x4F",
    "0x43"
]);
exports.add("nes", [
    "0x4E",
    "0x45",
    "0x53",
    "0x1A"
]);
exports.add("tar", [
    "0x75",
    "0x73",
    "0x74",
    "0x61",
    "0x72",
    "0x00",
    "0x30",
    "0x30"
], {
    // As per Mozilla documentation available at:
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
    // or wikipedia page:
    // https://en.wikipedia.org/wiki/List_of_archive_formats
    mime: "application/x-tar",
    extension: "tar"
}, 0x101);
exports.add("tar", [
    "0x75",
    "0x73",
    "0x74",
    "0x61",
    "0x72",
    "0x20",
    "0x20",
    "0x00"
], {
    mime: "application/x-tar",
    extension: "tar"
}, 0x101);
exports.add("tox", [
    "0x74",
    "0x6F",
    "0x78",
    "0x33"
]);
exports.add("mlv", [
    "0x4D",
    "0x4C",
    "0x56",
    "0x49"
]);
exports.add("windowsupdate", [
    "0x44",
    "0x43",
    "0x4D",
    "0x01",
    "0x50",
    "0x41",
    "0x33",
    "0x30"
]);
exports.add("7z", [
    "0x37",
    "0x7A",
    "0xBC",
    "0xAF",
    "0x27",
    "0x1C"
], {
    mime: "application/x-7z-compressed",
    extension: "7z"
});
exports.add("gz", [
    "0x1F",
    "0x8B"
], {
    mime: "application/gzip",
    extension: "gz"
});
exports.add("tar.gz", [
    "0x1F",
    "0x8B"
], {
    mime: "application/gzip",
    extension: "tar.gz"
});
exports.add("xz", [
    "0xFD",
    "0x37",
    "0x7A",
    "0x58",
    "0x5A",
    "0x00",
    "0x00"
], {
    mime: "application/gzip",
    extension: "xz"
});
exports.add("tar.xz", [
    "0xFD",
    "0x37",
    "0x7A",
    "0x58",
    "0x5A",
    "0x00",
    "0x00"
], {
    mime: "application/gzip",
    extension: "tar.xz"
});
exports.add("lz2", [
    "0x04",
    "0x22",
    "0x4D",
    "0x18"
]);
exports.add("cab", [
    "0x4D",
    "0x53",
    "0x43",
    "0x46"
]);
exports.add("mkv", [
    "0x1A",
    "0x45",
    "0xDF",
    "0xA3"
], {
    mime: "video/x-matroska",
    extension: "mkv"
});
exports.add("mka", [
    "0x1A",
    "0x45",
    "0xDF",
    "0xA3"
], {
    mime: "audio/x-matroska",
    extension: "mka"
});
exports.add("mks", [
    "0x1A",
    "0x45",
    "0xDF",
    "0xA3"
], {
    mime: "video/x-matroska",
    extension: "mks"
});
exports.add("mk3d", [
    "0x1A",
    "0x45",
    "0xDF",
    "0xA3"
]);
exports.add("webm", [
    "0x1A",
    "0x45",
    "0xDF",
    "0xA3"
], {
    mime: "audio/webm",
    extension: "webm"
});
exports.add("dcm", [
    "0x44",
    "0x49",
    "0x43",
    "0x4D"
], undefined, 0x80);
exports.add("xml", [
    "0x3C",
    "0x3f",
    "0x78",
    "0x6d",
    "0x6C",
    "0x20"
], {
    mime: "application/xml",
    extension: "xml"
});
exports.add("wasm", [
    "0x00",
    "0x61",
    "0x73",
    "0x6d"
], {
    mime: "application/wasm",
    extension: "wasm"
});
exports.add("lep", [
    "0xCF",
    "0x84",
    "0x01"
]);
exports.add("swf", [
    "0x43",
    "0x57",
    "0x53"
], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
});
exports.add("swf", [
    "0x46",
    "0x57",
    "0x53"
], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
});
exports.add("deb", [
    "0x21",
    "0x3C",
    "0x61",
    "0x72",
    "0x63",
    "0x68",
    "0x3E"
]);
exports.add("rtf", [
    "0x7B",
    "0x5C",
    "0x72",
    "0x74",
    "0x66",
    "0x31"
], {
    mime: "application/rtf",
    extension: "rtf"
});
exports.add("m2p", [
    "0x00",
    "0x00",
    "0x01",
    "0xBA"
]);
exports.add("vob", [
    "0x00",
    "0x00",
    "0x01",
    "0xBA"
]);
exports.add("mpg", [
    "0x00",
    "0x00",
    "0x01",
    "0xBA"
], {
    mime: "video/mpeg",
    extension: "mpg"
});
exports.add("mpeg", [
    "0x00",
    "0x00",
    "0x01",
    "0xBA"
], {
    mime: "video/mpeg",
    extension: "mpeg"
});
exports.add("mpeg", [
    "0x47"
], {
    mime: "video/mpeg",
    extension: "mpeg"
});
exports.add("mpeg", [
    "0x00",
    "0x00",
    "0x01",
    "0xB3"
], {
    mime: "video/mpeg",
    extension: "mpeg"
});
// mov 'free' TODO: find test file
exports.add("mov", [
    "0x66",
    "0x72",
    "0x65",
    "0x65"
], {
    mime: "video/quicktime",
    extension: "mov"
}, 0x4);
// mov 'mdat'
exports.add("mov", [
    "0x6D",
    "0x64",
    "0x61",
    "0x74"
], {
    mime: "video/quicktime",
    extension: "mov"
}, 0x4);
// mov 'moov' TODO: find test file
exports.add("mov", [
    "0x6D",
    "0x6F",
    "0x6F",
    "0x76"
], {
    mime: "video/quicktime",
    extension: "mov"
}, 0x4);
// move 'wide' TODO: find test file
exports.add("mov", [
    "0x77",
    "0x69",
    "0x64",
    "0x65"
], {
    mime: "video/quicktime",
    extension: "mov"
}, 0x4);
// mov 'ftypqt'
exports.add("mov", [
    "0x66",
    "0x74",
    "0x79",
    "0x70",
    "0x71",
    "0x74"
], {
    mime: "video/quicktime",
    extension: "mov"
}, 0x4);
exports.add("hl2demo", [
    "0x48",
    "0x4C",
    "0x32",
    "0x44",
    "0x45",
    "0x4D",
    "0x4F"
]);
exports.add("txt", [
    "0xEF",
    "0xBB",
    "0xBF"
], {
    mime: "text/plain; charset=UTF-8",
    extension: "txt"
});
exports.add("txt", [
    "0xFF",
    "0xFE"
], {
    mime: "text/plain; charset=UTF-16LE",
    extension: "txt"
});
exports.add("txt", [
    "0xFE",
    "0xFF"
], {
    mime: "text/plain; charset=UTF-16BE",
    extension: "txt"
});
exports.add("txt", [
    "0xFF",
    "0xFE",
    "0x00",
    "0x00"
], {
    mime: "text/plain; charset=UTF-32LE",
    extension: "txt"
});
exports.add("txt", [
    "0x00",
    "0x00",
    "0xFE",
    "0xFF"
], {
    mime: "text/plain; charset=UTF-32BE",
    extension: "txt"
});
exports.add("SubRip", [
    "0x31",
    "0x0D",
    "0x0A",
    "0x30",
    "0x30",
    "0x3A"
], {
    mime: "application/x-subrip",
    extension: "srt"
});
exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0A"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0D"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x20"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0xEF",
    "0xBB",
    "0xBF",
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x09"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0A"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x0D"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x20"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("WebVTT", [
    "0x57",
    "0x45",
    "0x42",
    "0x56",
    "0x54",
    "0x54",
    "0x09"
], {
    mime: "text/vtt",
    extension: "vtt"
});
exports.add("Json", [
    "0x7B"
], {
    mime: "application/json",
    extension: ".json"
});
exports.add("Json", [
    "0x5B"
], {
    mime: "application/json",
    extension: ".json"
});
exports.add("ELF", [
    "0x7F",
    "0x45",
    "0x4C",
    "0x46"
], {
    mime: "application/x-executable",
    extension: ".elf"
});
exports.add("Mach-O", [
    "0xFE",
    "0xED",
    "0xFA",
    "0xC"
], {
    mime: "application/x-mach-binary",
    extension: ".o"
});
exports.add("Mach-O", [
    "0xFE",
    "0xED",
    "0xFA",
    "0xCF"
], {
    mime: "application/x-executable",
    extension: "elf"
});
exports.add("EML", [
    "0x52",
    "0x65",
    "0x63",
    "0x65",
    "0x69",
    "0x76",
    "0x65",
    "0x64",
    "0x3A"
], {
    mime: "message/rfc822",
    extension: ".eml"
});
exports.add("SVG", [
    "0x3c",
    "0x73",
    "0x76",
    "0x67"
], {
    mime: "image/svg+xml",
    extension: "svg"
});
exports.add("avif", [
    "0x66",
    "0x74",
    "0x79",
    "0x70",
    "0x61",
    "0x76",
    "0x69",
    "0x66"
], {
    mime: "image/avif",
    extension: "avif"
}, 4);
const createTree = ()=>tree;
exports.createTree = createTree;
exports.default = ()=>tree;
}}),
"[project]/node_modules/magic-bytes.js/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { m: module, e: exports } = __turbopack_context__;
{
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.register = exports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = void 0;
const pattern_tree_1 = __turbopack_context__.r("[project]/node_modules/magic-bytes.js/dist/model/pattern-tree.js [app-route] (ecmascript)");
const toHex_1 = __turbopack_context__.r("[project]/node_modules/magic-bytes.js/dist/model/toHex.js [app-route] (ecmascript)");
const patternTree = pattern_tree_1.createTree();
const filetypeinfo = (bytes)=>{
    let tree = patternTree;
    for (const k of Object.keys(tree.offset)){
        const offset = toHex_1.fromHex(k);
        const offsetExceedsFile = offset >= bytes.length;
        if (offsetExceedsFile) {
            continue;
        }
        const node = patternTree.offset[k];
        const guessed = walkTree(offset, bytes, node);
        if (guessed.length > 0) {
            return guessed;
        }
    }
    if (tree.noOffset === null) {
        return [];
    }
    return walkTree(0, bytes, tree.noOffset);
};
exports.filetypeinfo = filetypeinfo;
const walkTree = (index, bytes, node)=>{
    let step = node;
    let guessFile = [];
    while(true){
        const currentByte = toHex_1.toHex(bytes[index]);
        if (step.bytes["?"] && !step.bytes[currentByte]) {
            step = step.bytes["?"];
        } else {
            step = step.bytes[currentByte];
        }
        if (!step) {
            return guessFile;
        }
        if (step && step.matches) {
            guessFile = step.matches.slice(0);
        }
        index += 1;
    }
};
exports.default = exports.filetypeinfo;
const filetypename = (bytes)=>exports.filetypeinfo(bytes).map((e)=>e.typename);
exports.filetypename = filetypename;
const filetypemime = (bytes)=>exports.filetypeinfo(bytes).map((e)=>e.mime ? e.mime : null).filter((x)=>x !== null);
exports.filetypemime = filetypemime;
const filetypeextension = (bytes)=>exports.filetypeinfo(bytes).map((e)=>e.extension ? e.extension : null).filter((x)=>x !== null);
exports.filetypeextension = filetypeextension;
const register = (typename, signature, additionalInfo, offset)=>{
    pattern_tree_1.add(typename, signature, additionalInfo, offset);
};
exports.register = register;
}}),
"[project]/node_modules/@sapphire/async-queue/dist/esm/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "AsyncQueue": ()=>AsyncQueue
});
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
var __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
// src/lib/_AsyncQueueEntry.ts
var _AsyncQueueEntry = class _AsyncQueueEntry {
    constructor(queue){
        __publicField(this, "promise");
        __publicField(this, "resolve");
        __publicField(this, "reject");
        __publicField(this, "queue");
        __publicField(this, "signal", null);
        __publicField(this, "signalListener", null);
        this.queue = queue;
        this.promise = new Promise((resolve, reject)=>{
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    setSignal(signal) {
        if (signal.aborted) return this;
        this.signal = signal;
        this.signalListener = ()=>{
            const index = this.queue["promises"].indexOf(this);
            if (index !== -1) this.queue["promises"].splice(index, 1);
            this.reject(new Error("Request aborted manually"));
        };
        this.signal.addEventListener("abort", this.signalListener);
        return this;
    }
    use() {
        this.dispose();
        this.resolve();
        return this;
    }
    abort() {
        this.dispose();
        this.reject(new Error("Request aborted manually"));
        return this;
    }
    dispose() {
        if (this.signal) {
            this.signal.removeEventListener("abort", this.signalListener);
            this.signal = null;
            this.signalListener = null;
        }
    }
};
__name(_AsyncQueueEntry, "AsyncQueueEntry");
var AsyncQueueEntry = _AsyncQueueEntry;
// src/lib/AsyncQueue.ts
var _AsyncQueue = class _AsyncQueue {
    constructor(){
        /**
     * The promises array
     */ __publicField(this, "promises", []);
    }
    /**
   * The amount of entries in the queue, including the head.
   * @seealso {@link queued} for the queued count.
   */ get remaining() {
        return this.promises.length;
    }
    /**
   * The amount of queued entries.
   * @seealso {@link remaining} for the count with the head.
   */ get queued() {
        return this.remaining === 0 ? 0 : this.remaining - 1;
    }
    /**
   * Waits for last promise and queues a new one
   * @example
   * ```typescript
   * const queue = new AsyncQueue();
   * async function request(url, options) {
   *     await queue.wait({ signal: options.signal });
   *     try {
   *         const result = await fetch(url, options);
   *         // Do some operations with 'result'
   *     } finally {
   *         // Remove first entry from the queue and resolve for the next entry
   *         queue.shift();
   *     }
   * }
   *
   * request(someUrl1, someOptions1); // Will call fetch() immediately
   * request(someUrl2, someOptions2); // Will call fetch() after the first finished
   * request(someUrl3, someOptions3); // Will call fetch() after the second finished
   * ```
   */ wait(options) {
        const entry = new AsyncQueueEntry(this);
        if (this.promises.length === 0) {
            this.promises.push(entry);
            return Promise.resolve();
        }
        this.promises.push(entry);
        if (options?.signal) entry.setSignal(options.signal);
        return entry.promise;
    }
    /**
   * Unlocks the head lock and transfers the next lock (if any) to the head.
   */ shift() {
        if (this.promises.length === 0) return;
        if (this.promises.length === 1) {
            this.promises.shift();
            return;
        }
        this.promises.shift();
        this.promises[0].use();
    }
    /**
   * Aborts all the pending promises.
   * @note To avoid race conditions, this does **not** unlock the head lock.
   */ abortAll() {
        if (this.queued === 0) return;
        for(let i = 1; i < this.promises.length; ++i){
            this.promises[i].abort();
        }
        this.promises.length = 1;
    }
};
__name(_AsyncQueue, "AsyncQueue");
var AsyncQueue = _AsyncQueue;
;
 //# sourceMappingURL=index.mjs.map
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@discordjs/rest/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s({
    "ALLOWED_EXTENSIONS": ()=>ALLOWED_EXTENSIONS,
    "ALLOWED_SIZES": ()=>ALLOWED_SIZES,
    "ALLOWED_STICKER_EXTENSIONS": ()=>ALLOWED_STICKER_EXTENSIONS,
    "BurstHandlerMajorIdKey": ()=>BurstHandlerMajorIdKey,
    "CDN": ()=>CDN,
    "DEPRECATION_WARNING_PREFIX": ()=>DEPRECATION_WARNING_PREFIX,
    "DefaultRestOptions": ()=>DefaultRestOptions,
    "DefaultUserAgent": ()=>DefaultUserAgent,
    "DefaultUserAgentAppendix": ()=>DefaultUserAgentAppendix,
    "DiscordAPIError": ()=>DiscordAPIError,
    "HTTPError": ()=>HTTPError,
    "OverwrittenMimeTypes": ()=>OverwrittenMimeTypes,
    "REST": ()=>REST,
    "RESTEvents": ()=>RESTEvents,
    "RateLimitError": ()=>RateLimitError,
    "RequestMethod": ()=>RequestMethod,
    "calculateUserDefaultAvatarIndex": ()=>calculateUserDefaultAvatarIndex,
    "makeURLSearchParams": ()=>makeURLSearchParams,
    "parseResponse": ()=>parseResponse,
    "version": ()=>version
});
// src/index.ts
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:buffer [external] (node:buffer, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$util$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@discordjs/util/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@discordjs/rest/node_modules/undici/index.js [app-route] (ecmascript)");
// src/strategies/undiciRequest.ts
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:http [external] (node:http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:url [external] (node:url, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:util [external] (node:util, cjs)");
// src/lib/CDN.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$discord$2d$api$2d$types$2f$v10$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@discordjs/rest/node_modules/discord-api-types/v10.mjs [app-route] (ecmascript)");
// src/lib/REST.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f40$discordjs$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@discordjs/rest/node_modules/@discordjs/collection/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sapphire$2f$snowflake$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sapphire/snowflake/dist/esm/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vladfrangu$2f$async_event_emitter$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@vladfrangu/async_event_emitter/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$magic$2d$bytes$2e$js$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/magic-bytes.js/dist/index.js [app-route] (ecmascript)");
// src/lib/handlers/SequentialHandler.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sapphire$2f$async$2d$queue$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@sapphire/async-queue/dist/esm/index.mjs [app-route] (ecmascript)");
var __defProp = Object.defineProperty;
var __name = (target, value)=>__defProp(target, "name", {
        value,
        configurable: true
    });
;
;
;
// src/environment.ts
var defaultStrategy;
function setDefaultStrategy(newStrategy) {
    defaultStrategy = newStrategy;
}
__name(setDefaultStrategy, "setDefaultStrategy");
function getDefaultStrategy() {
    return defaultStrategy;
}
__name(getDefaultStrategy, "getDefaultStrategy");
;
;
;
;
async function makeRequest(url, init) {
    const options = {
        ...init,
        body: await resolveBody(init.body)
    };
    const res = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["request"])(url, options);
    return {
        body: res.body,
        async arrayBuffer () {
            return res.body.arrayBuffer();
        },
        async json () {
            return res.body.json();
        },
        async text () {
            return res.body.text();
        },
        get bodyUsed () {
            return res.body.bodyUsed;
        },
        headers: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Headers"](res.headers),
        status: res.statusCode,
        statusText: __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["STATUS_CODES"][res.statusCode],
        ok: res.statusCode >= 200 && res.statusCode < 300
    };
}
__name(makeRequest, "makeRequest");
async function resolveBody(body) {
    if (body == null) {
        return null;
    } else if (typeof body === "string") {
        return body;
    } else if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["types"].isUint8Array(body)) {
        return body;
    } else if (__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$util__$5b$external$5d$__$28$node$3a$util$2c$__cjs$29$__["types"].isArrayBuffer(body)) {
        return new Uint8Array(body);
    } else if (body instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$url__$5b$external$5d$__$28$node$3a$url$2c$__cjs$29$__["URLSearchParams"]) {
        return body.toString();
    } else if (body instanceof DataView) {
        return new Uint8Array(body.buffer);
    } else if (body instanceof Blob) {
        return new Uint8Array(await body.arrayBuffer());
    } else if (body instanceof FormData) {
        return body;
    } else if (body[Symbol.iterator]) {
        const chunks = [
            ...body
        ];
        return Buffer.concat(chunks);
    } else if (body[Symbol.asyncIterator]) {
        const chunks = [];
        for await (const chunk of body){
            chunks.push(chunk);
        }
        return Buffer.concat(chunks);
    }
    throw new TypeError(`Unable to resolve body.`);
}
__name(resolveBody, "resolveBody");
;
;
;
var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.6.0)`;
var DefaultUserAgentAppendix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$util$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUserAgentAppendix"])();
var DefaultRestOptions = {
    agent: null,
    api: "https://discord.com/api",
    authPrefix: "Bot",
    cdn: "https://cdn.discordapp.com",
    headers: {},
    invalidRequestWarningInterval: 0,
    globalRequestsPerSecond: 50,
    offset: 50,
    rejectOnRateLimit: null,
    retries: 3,
    timeout: 15e3,
    userAgentAppendix: DefaultUserAgentAppendix,
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$discord$2d$api$2d$types$2f$v10$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["APIVersion"],
    hashSweepInterval: 144e5,
    // 4 Hours
    hashLifetime: 864e5,
    // 24 Hours
    handlerSweepInterval: 36e5,
    // 1 Hour
    async makeRequest (...args) {
        return getDefaultStrategy()(...args);
    },
    mediaProxy: "https://media.discordapp.net"
};
var RESTEvents = /* @__PURE__ */ ((RESTEvents2)=>{
    RESTEvents2["Debug"] = "restDebug";
    RESTEvents2["HandlerSweep"] = "handlerSweep";
    RESTEvents2["HashSweep"] = "hashSweep";
    RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
    RESTEvents2["RateLimited"] = "rateLimited";
    RESTEvents2["Response"] = "response";
    return RESTEvents2;
})(RESTEvents || {});
var ALLOWED_EXTENSIONS = [
    "webp",
    "png",
    "jpg",
    "jpeg",
    "gif"
];
var ALLOWED_STICKER_EXTENSIONS = [
    "png",
    "json",
    "gif"
];
var ALLOWED_SIZES = [
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096
];
var OverwrittenMimeTypes = {
    // https://github.com/discordjs/discord.js/issues/8557
    "image/apng": "image/png"
};
var BurstHandlerMajorIdKey = "burst";
var DEPRECATION_WARNING_PREFIX = "DeprecationWarning";
// src/lib/errors/RateLimitError.ts
var RateLimitError = class _RateLimitError extends Error {
    static{
        __name(this, "RateLimitError");
    }
    timeToReset;
    limit;
    method;
    hash;
    url;
    route;
    majorParameter;
    global;
    retryAfter;
    sublimitTimeout;
    scope;
    constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global, retryAfter, sublimitTimeout, scope }){
        super();
        this.timeToReset = timeToReset;
        this.limit = limit;
        this.method = method;
        this.hash = hash;
        this.url = url;
        this.route = route;
        this.majorParameter = majorParameter;
        this.global = global;
        this.retryAfter = retryAfter;
        this.sublimitTimeout = sublimitTimeout;
        this.scope = scope;
    }
    /**
   * The name of the error
   */ get name() {
        return `${_RateLimitError.name}[${this.route}]`;
    }
};
// src/lib/utils/types.ts
var RequestMethod = /* @__PURE__ */ ((RequestMethod2)=>{
    RequestMethod2["Delete"] = "DELETE";
    RequestMethod2["Get"] = "GET";
    RequestMethod2["Patch"] = "PATCH";
    RequestMethod2["Post"] = "POST";
    RequestMethod2["Put"] = "PUT";
    return RequestMethod2;
})(RequestMethod || {});
// src/lib/utils/utils.ts
function serializeSearchParam(value) {
    switch(typeof value){
        case "string":
            return value;
        case "number":
        case "bigint":
        case "boolean":
            return value.toString();
        case "object":
            if (value === null) return null;
            if (value instanceof Date) {
                return Number.isNaN(value.getTime()) ? null : value.toISOString();
            }
            if (typeof value.toString === "function" && value.toString !== Object.prototype.toString) return value.toString();
            return null;
        default:
            return null;
    }
}
__name(serializeSearchParam, "serializeSearchParam");
function makeURLSearchParams(options) {
    const params = new URLSearchParams();
    if (!options) return params;
    for (const [key, value] of Object.entries(options)){
        const serialized = serializeSearchParam(value);
        if (serialized !== null) params.append(key, serialized);
    }
    return params;
}
__name(makeURLSearchParams, "makeURLSearchParams");
async function parseResponse(res) {
    if (res.headers.get("Content-Type")?.startsWith("application/json")) {
        return res.json();
    }
    return res.arrayBuffer();
}
__name(parseResponse, "parseResponse");
function hasSublimit(bucketRoute, body, method) {
    if (bucketRoute === "/channels/:id") {
        if (typeof body !== "object" || body === null) return false;
        if (method !== "PATCH" /* Patch */ ) return false;
        const castedBody = body;
        return [
            "name",
            "topic"
        ].some((key)=>Reflect.has(castedBody, key));
    }
    return true;
}
__name(hasSublimit, "hasSublimit");
function shouldRetry(error) {
    if (error.name === "AbortError") return true;
    return "code" in error && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
}
__name(shouldRetry, "shouldRetry");
async function onRateLimit(manager, rateLimitData) {
    const { options } = manager;
    if (!options.rejectOnRateLimit) return;
    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route)=>rateLimitData.route.startsWith(route.toLowerCase()));
    if (shouldThrow) {
        throw new RateLimitError(rateLimitData);
    }
}
__name(onRateLimit, "onRateLimit");
function calculateUserDefaultAvatarIndex(userId) {
    return Number(BigInt(userId) >> 22n) % 6;
}
__name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
async function sleep(ms) {
    return new Promise((resolve)=>{
        setTimeout(()=>resolve(), ms);
    });
}
__name(sleep, "sleep");
function isBufferLike(value) {
    return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
}
__name(isBufferLike, "isBufferLike");
function deprecationWarning(message) {
    if (typeof globalThis.process === "undefined") {
        console.warn(`${DEPRECATION_WARNING_PREFIX}: ${message}`);
    } else {
        process.emitWarning(message, DEPRECATION_WARNING_PREFIX);
    }
}
__name(deprecationWarning, "deprecationWarning");
function normalizeRateLimitOffset(offset, route) {
    if (typeof offset === "number") {
        return Math.max(0, offset);
    }
    const result = offset(route);
    return Math.max(0, result);
}
__name(normalizeRateLimitOffset, "normalizeRateLimitOffset");
// src/lib/CDN.ts
var deprecationEmittedForEmoji = false;
var CDN = class {
    constructor(cdn = DefaultRestOptions.cdn, mediaProxy = DefaultRestOptions.mediaProxy){
        this.cdn = cdn;
        this.mediaProxy = mediaProxy;
    }
    static{
        __name(this, "CDN");
    }
    /**
   * Generates an app asset URL for a client's asset.
   *
   * @param clientId - The client id that has the asset
   * @param assetHash - The hash provided by Discord for this asset
   * @param options - Optional options for the asset
   */ appAsset(clientId, assetHash, options) {
        return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
    }
    /**
   * Generates an app icon URL for a client's icon.
   *
   * @param clientId - The client id that has the icon
   * @param iconHash - The hash provided by Discord for this icon
   * @param options - Optional options for the icon
   */ appIcon(clientId, iconHash, options) {
        return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
    }
    /**
   * Generates an avatar URL, e.g. for a user or a webhook.
   *
   * @param id - The id that has the icon
   * @param avatarHash - The hash provided by Discord for this avatar
   * @param options - Optional options for the avatar
   */ avatar(id, avatarHash, options) {
        return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
    }
    avatarDecoration(userIdOrAsset, userAvatarDecoration, options) {
        if (userAvatarDecoration) {
            return this.makeURL(`/avatar-decorations/${userIdOrAsset}/${userAvatarDecoration}`, options);
        }
        return this.makeURL(`/avatar-decoration-presets/${userIdOrAsset}`, {
            extension: "png"
        });
    }
    /**
   * Generates a banner URL, e.g. for a user or a guild.
   *
   * @param id - The id that has the banner splash
   * @param bannerHash - The hash provided by Discord for this banner
   * @param options - Optional options for the banner
   */ banner(id, bannerHash, options) {
        return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
    }
    /**
   * Generates an icon URL for a channel, e.g. a group DM.
   *
   * @param channelId - The channel id that has the icon
   * @param iconHash - The hash provided by Discord for this channel
   * @param options - Optional options for the icon
   */ channelIcon(channelId, iconHash, options) {
        return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
    }
    /**
   * Generates a default avatar URL
   *
   * @param index - The default avatar index
   * @remarks
   * To calculate the index for a user do `(userId >> 22) % 6`,
   * or `discriminator % 5` if they're using the legacy username system.
   */ defaultAvatar(index) {
        return this.makeURL(`/embed/avatars/${index}`, {
            extension: "png"
        });
    }
    /**
   * Generates a discovery splash URL for a guild's discovery splash.
   *
   * @param guildId - The guild id that has the discovery splash
   * @param splashHash - The hash provided by Discord for this splash
   * @param options - Optional options for the splash
   */ discoverySplash(guildId, splashHash, options) {
        return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
    }
    emoji(emojiId, options) {
        let resolvedOptions;
        if (typeof options === "string") {
            if (!deprecationEmittedForEmoji) {
                deprecationWarning("Passing a string for the second parameter of CDN#emoji() is deprecated. Use an object instead.");
                deprecationEmittedForEmoji = true;
            }
            resolvedOptions = {
                extension: options
            };
        } else {
            resolvedOptions = options;
        }
        return this.makeURL(`/emojis/${emojiId}`, resolvedOptions);
    }
    /**
   * Generates a guild member avatar URL.
   *
   * @param guildId - The id of the guild
   * @param userId - The id of the user
   * @param avatarHash - The hash provided by Discord for this avatar
   * @param options - Optional options for the avatar
   */ guildMemberAvatar(guildId, userId, avatarHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
    }
    /**
   * Generates a guild member banner URL.
   *
   * @param guildId - The id of the guild
   * @param userId - The id of the user
   * @param bannerHash - The hash provided by Discord for this banner
   * @param options - Optional options for the banner
   */ guildMemberBanner(guildId, userId, bannerHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banners/${bannerHash}`, bannerHash, options);
    }
    /**
   * Generates an icon URL, e.g. for a guild.
   *
   * @param id - The id that has the icon splash
   * @param iconHash - The hash provided by Discord for this icon
   * @param options - Optional options for the icon
   */ icon(id, iconHash, options) {
        return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
    }
    /**
   * Generates a URL for the icon of a role
   *
   * @param roleId - The id of the role that has the icon
   * @param roleIconHash - The hash provided by Discord for this role icon
   * @param options - Optional options for the role icon
   */ roleIcon(roleId, roleIconHash, options) {
        return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
    }
    /**
   * Generates a guild invite splash URL for a guild's invite splash.
   *
   * @param guildId - The guild id that has the invite splash
   * @param splashHash - The hash provided by Discord for this splash
   * @param options - Optional options for the splash
   */ splash(guildId, splashHash, options) {
        return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
    }
    /**
   * Generates a sticker URL.
   *
   * @param stickerId - The sticker id
   * @param extension - The extension of the sticker
   * @privateRemarks
   * Stickers cannot have a `.webp` extension, so we default to a `.png`.
   * Sticker GIFs do not use the CDN base URL.
   */ sticker(stickerId, extension = "png") {
        return this.makeURL(`/stickers/${stickerId}`, {
            allowedExtensions: ALLOWED_STICKER_EXTENSIONS,
            base: extension === "gif" ? this.mediaProxy : this.cdn,
            extension
        });
    }
    /**
   * Generates a sticker pack banner URL.
   *
   * @param bannerId - The banner id
   * @param options - Optional options for the banner
   */ stickerPackBanner(bannerId, options) {
        return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
    }
    /**
   * Generates a team icon URL for a team's icon.
   *
   * @param teamId - The team id that has the icon
   * @param iconHash - The hash provided by Discord for this icon
   * @param options - Optional options for the icon
   */ teamIcon(teamId, iconHash, options) {
        return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
    }
    /**
   * Generates a cover image for a guild scheduled event.
   *
   * @param scheduledEventId - The scheduled event id
   * @param coverHash - The hash provided by discord for this cover image
   * @param options - Optional options for the cover image
   */ guildScheduledEventCover(scheduledEventId, coverHash, options) {
        return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
    }
    /**
   * Generates a URL for a soundboard sound.
   *
   * @param soundId - The soundboard sound id
   */ soundboardSound(soundId) {
        return `${this.cdn}${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$discord$2d$api$2d$types$2f$v10$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CDNRoutes"].soundboardSound(soundId)}`;
    }
    /**
   * Generates a URL for a guild tag badge.
   *
   * @param guildId - The guild id
   * @param badgeHash - The hash of the badge
   * @param options - Optional options for the badge
   */ guildTagBadge(guildId, badgeHash, options) {
        return this.makeURL(`/guild-tag-badges/${guildId}/${badgeHash}`, options);
    }
    /**
   * Constructs the URL for the resource, checking whether or not `hash` starts with `a_` if `dynamic` is set to `true`.
   *
   * @param route - The base cdn route
   * @param hash - The hash provided by Discord for this icon
   * @param options - Optional options for the link
   */ dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
        return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? {
            ...options,
            extension: "gif"
        } : options);
    }
    /**
   * Constructs the URL for the resource
   *
   * @param route - The base cdn route
   * @param options - The extension/size options for the link
   */ makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, base = this.cdn, extension = "webp", size, animated } = {}) {
        extension = String(extension).toLowerCase();
        if (!allowedExtensions.includes(extension)) {
            throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
        }
        if (size && !ALLOWED_SIZES.includes(size)) {
            throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
        }
        const url = new URL(`${base}${route}.${extension}`);
        if (animated !== void 0) {
            url.searchParams.set("animated", String(animated));
        }
        if (size) {
            url.searchParams.set("size", String(size));
        }
        return url.toString();
    }
};
// src/lib/errors/DiscordAPIError.ts
function isErrorGroupWrapper(error) {
    return Reflect.has(error, "_errors");
}
__name(isErrorGroupWrapper, "isErrorGroupWrapper");
function isErrorResponse(error) {
    return typeof Reflect.get(error, "message") === "string";
}
__name(isErrorResponse, "isErrorResponse");
var DiscordAPIError = class _DiscordAPIError extends Error {
    /**
   * @param rawError - The error reported by Discord
   * @param code - The error code reported by Discord
   * @param status - The status code of the response
   * @param method - The method of the request that erred
   * @param url - The url of the request that erred
   * @param bodyData - The unparsed data for the request that errored
   */ constructor(rawError, code, status, method, url, bodyData){
        super(_DiscordAPIError.getMessage(rawError));
        this.rawError = rawError;
        this.code = code;
        this.status = status;
        this.method = method;
        this.url = url;
        this.requestBody = {
            files: bodyData.files,
            json: bodyData.body
        };
    }
    static{
        __name(this, "DiscordAPIError");
    }
    requestBody;
    /**
   * The name of the error
   */ get name() {
        return `${_DiscordAPIError.name}[${this.code}]`;
    }
    static getMessage(error) {
        let flattened = "";
        if ("code" in error) {
            if (error.errors) {
                flattened = [
                    ...this.flattenDiscordError(error.errors)
                ].join("\n");
            }
            return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
        }
        return error.error_description ?? "No Description";
    }
    static *flattenDiscordError(obj, key = "") {
        if (isErrorResponse(obj)) {
            return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
        }
        for (const [otherKey, val] of Object.entries(obj)){
            const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
            if (typeof val === "string") {
                yield val;
            } else if (isErrorGroupWrapper(val)) {
                for (const error of val._errors){
                    yield* this.flattenDiscordError(error, nextKey);
                }
            } else {
                yield* this.flattenDiscordError(val, nextKey);
            }
        }
    }
};
// src/lib/errors/HTTPError.ts
var HTTPError = class _HTTPError extends Error {
    /**
   * @param status - The status code of the response
   * @param statusText - The status text of the response
   * @param method - The method of the request that erred
   * @param url - The url of the request that erred
   * @param bodyData - The unparsed data for the request that errored
   */ constructor(status, statusText, method, url, bodyData){
        super(statusText);
        this.status = status;
        this.method = method;
        this.url = url;
        this.requestBody = {
            files: bodyData.files,
            json: bodyData.body
        };
    }
    static{
        __name(this, "HTTPError");
    }
    requestBody;
    name = _HTTPError.name;
};
;
;
;
;
// src/lib/handlers/Shared.ts
var invalidCount = 0;
var invalidCountResetTime = null;
function incrementInvalidCount(manager) {
    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
        invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
        invalidCount = 0;
    }
    invalidCount++;
    const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
    if (emitInvalid) {
        manager.emit("invalidRequestWarning" /* InvalidRequestWarning */ , {
            count: invalidCount,
            remainingTime: invalidCountResetTime - Date.now()
        });
    }
}
__name(incrementInvalidCount, "incrementInvalidCount");
async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
    const controller = new AbortController();
    const timeout = setTimeout(()=>controller.abort(), manager.options.timeout);
    if (requestData.signal) {
        if (requestData.signal.aborted) controller.abort();
        else requestData.signal.addEventListener("abort", ()=>controller.abort());
    }
    let res;
    try {
        res = await manager.options.makeRequest(url, {
            ...options,
            signal: controller.signal
        });
    } catch (error) {
        if (!(error instanceof Error)) throw error;
        if (shouldRetry(error) && retries !== manager.options.retries) {
            return null;
        }
        throw error;
    } finally{
        clearTimeout(timeout);
    }
    if (manager.listenerCount("response" /* Response */ )) {
        manager.emit("response" /* Response */ , {
            method: options.method ?? "get",
            path: routeId.original,
            route: routeId.bucketRoute,
            options,
            data: requestData,
            retries
        }, res instanceof Response ? res.clone() : {
            ...res
        });
    }
    return res;
}
__name(makeNetworkRequest, "makeNetworkRequest");
async function handleErrors(manager, res, method, url, requestData, retries) {
    const status = res.status;
    if (status >= 500 && status < 600) {
        if (retries !== manager.options.retries) {
            return null;
        }
        throw new HTTPError(status, res.statusText, method, url, requestData);
    } else {
        if (status >= 400 && status < 500) {
            if (status === 401 && requestData.auth) {
                manager.setToken(null);
            }
            const data = await parseResponse(res);
            throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
        }
        return res;
    }
}
__name(handleErrors, "handleErrors");
// src/lib/handlers/BurstHandler.ts
var BurstHandler = class {
    /**
   * @param manager - The request manager
   * @param hash - The hash that this RequestHandler handles
   * @param majorParameter - The major parameter for this handler
   */ constructor(manager, hash, majorParameter){
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
    }
    static{
        __name(this, "BurstHandler");
    }
    /**
   * {@inheritdoc IHandler.id}
   */ id;
    /**
   * {@inheritDoc IHandler.inactive}
   */ inactive = false;
    /**
   * Emits a debug message
   *
   * @param message - The message to debug
   */ debug(message) {
        this.manager.emit("restDebug" /* Debug */ , `[REST ${this.id}] ${message}`);
    }
    /**
   * {@inheritDoc IHandler.queueRequest}
   */ async queueRequest(routeId, url, options, requestData) {
        return this.runRequest(routeId, url, options, requestData);
    }
    /**
   * The method that actually makes the request to the API, and updates info about the bucket accordingly
   *
   * @param routeId - The generalized API route with literal ids for major parameters
   * @param url - The fully resolved URL to make the request to
   * @param options - The fetch options needed to make the request
   * @param requestData - Extra data from the user's request needed for errors and additional processing
   * @param retries - The number of retries this request has already attempted (recursion)
   */ async runRequest(routeId, url, options, requestData, retries = 0) {
        const method = options.method ?? "get";
        const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
        if (res === null) {
            return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        const status = res.status;
        let retryAfter = 0;
        const retry = res.headers.get("Retry-After");
        const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
        if (retry) retryAfter = Number(retry) * 1e3 + offset;
        if (status === 401 || status === 403 || status === 429) {
            incrementInvalidCount(this.manager);
        }
        if (status >= 200 && status < 300) {
            return res;
        } else if (status === 429) {
            const isGlobal = res.headers.has("X-RateLimit-Global");
            const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
            await onRateLimit(this.manager, {
                global: isGlobal,
                method,
                url,
                route: routeId.bucketRoute,
                majorParameter: this.majorParameter,
                hash: this.hash,
                limit: Number.POSITIVE_INFINITY,
                timeToReset: retryAfter,
                retryAfter,
                sublimitTimeout: 0,
                scope
            });
            this.debug([
                "Encountered unexpected 429 rate limit",
                `  Global         : ${isGlobal}`,
                `  Method         : ${method}`,
                `  URL            : ${url}`,
                `  Bucket         : ${routeId.bucketRoute}`,
                `  Major parameter: ${routeId.majorParameter}`,
                `  Hash           : ${this.hash}`,
                `  Limit          : ${Number.POSITIVE_INFINITY}`,
                `  Retry After    : ${retryAfter}ms`,
                `  Sublimit       : None`,
                `  Scope          : ${scope}`
            ].join("\n"));
            await sleep(retryAfter);
            return this.runRequest(routeId, url, options, requestData, retries);
        } else {
            const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
            if (handled === null) {
                return this.runRequest(routeId, url, options, requestData, ++retries);
            }
            return handled;
        }
    }
};
;
var SequentialHandler = class {
    /**
   * @param manager - The request manager
   * @param hash - The hash that this RequestHandler handles
   * @param majorParameter - The major parameter for this handler
   */ constructor(manager, hash, majorParameter){
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
    }
    static{
        __name(this, "SequentialHandler");
    }
    /**
   * {@inheritDoc IHandler.id}
   */ id;
    /**
   * The time this rate limit bucket will reset
   */ reset = -1;
    /**
   * The remaining requests that can be made before we are rate limited
   */ remaining = 1;
    /**
   * The total number of requests that can be made before we are rate limited
   */ limit = Number.POSITIVE_INFINITY;
    /**
   * The interface used to sequence async requests sequentially
   */ #asyncQueue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sapphire$2f$async$2d$queue$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncQueue"]();
    /**
   * The interface used to sequence sublimited async requests sequentially
   */ #sublimitedQueue = null;
    /**
   * A promise wrapper for when the sublimited queue is finished being processed or null when not being processed
   */ #sublimitPromise = null;
    /**
   * Whether the sublimit queue needs to be shifted in the finally block
   */ #shiftSublimit = false;
    /**
   * {@inheritDoc IHandler.inactive}
   */ get inactive() {
        return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
    }
    /**
   * If the rate limit bucket is currently limited by the global limit
   */ get globalLimited() {
        return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
    }
    /**
   * If the rate limit bucket is currently limited by its limit
   */ get localLimited() {
        return this.remaining <= 0 && Date.now() < this.reset;
    }
    /**
   * If the rate limit bucket is currently limited
   */ get limited() {
        return this.globalLimited || this.localLimited;
    }
    /**
   * The time until queued requests can continue
   */ getTimeToReset(routeId) {
        const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
        return this.reset + offset - Date.now();
    }
    /**
   * Emits a debug message
   *
   * @param message - The message to debug
   */ debug(message) {
        this.manager.emit("restDebug" /* Debug */ , `[REST ${this.id}] ${message}`);
    }
    /**
   * Delay all requests for the specified amount of time, handling global rate limits
   *
   * @param time - The amount of time to delay all requests for
   */ async globalDelayFor(time) {
        await sleep(time);
        this.manager.globalDelay = null;
    }
    /**
   * {@inheritDoc IHandler.queueRequest}
   */ async queueRequest(routeId, url, options, requestData) {
        let queue = this.#asyncQueue;
        let queueType = 0 /* Standard */ ;
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
            queue = this.#sublimitedQueue;
            queueType = 1 /* Sublimit */ ;
        }
        await queue.wait({
            signal: requestData.signal
        });
        if (queueType === 0 /* Standard */ ) {
            if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
                queue = this.#sublimitedQueue;
                const wait = queue.wait();
                this.#asyncQueue.shift();
                await wait;
            } else if (this.#sublimitPromise) {
                await this.#sublimitPromise.promise;
            }
        }
        try {
            return await this.runRequest(routeId, url, options, requestData);
        } finally{
            queue.shift();
            if (this.#shiftSublimit) {
                this.#shiftSublimit = false;
                this.#sublimitedQueue?.shift();
            }
            if (this.#sublimitedQueue?.remaining === 0) {
                this.#sublimitPromise?.resolve();
                this.#sublimitedQueue = null;
            }
        }
    }
    /**
   * The method that actually makes the request to the api, and updates info about the bucket accordingly
   *
   * @param routeId - The generalized api route with literal ids for major parameters
   * @param url - The fully resolved url to make the request to
   * @param options - The fetch options needed to make the request
   * @param requestData - Extra data from the user's request needed for errors and additional processing
   * @param retries - The number of retries this request has already attempted (recursion)
   */ async runRequest(routeId, url, options, requestData, retries = 0) {
        while(this.limited){
            const isGlobal = this.globalLimited;
            let limit2;
            let timeout;
            let delay;
            if (isGlobal) {
                const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
                limit2 = this.manager.options.globalRequestsPerSecond;
                timeout = this.manager.globalReset + offset2 - Date.now();
                if (!this.manager.globalDelay) {
                    this.manager.globalDelay = this.globalDelayFor(timeout);
                }
                delay = this.manager.globalDelay;
            } else {
                limit2 = this.limit;
                timeout = this.getTimeToReset(routeId);
                delay = sleep(timeout);
            }
            const rateLimitData = {
                global: isGlobal,
                method: options.method ?? "get",
                url,
                route: routeId.bucketRoute,
                majorParameter: this.majorParameter,
                hash: this.hash,
                limit: limit2,
                timeToReset: timeout,
                retryAfter: timeout,
                sublimitTimeout: 0,
                scope: "user"
            };
            this.manager.emit("rateLimited" /* RateLimited */ , rateLimitData);
            await onRateLimit(this.manager, rateLimitData);
            if (isGlobal) {
                this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
            } else {
                this.debug(`Waiting ${timeout}ms for rate limit to pass`);
            }
            await delay;
        }
        if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
            this.manager.globalReset = Date.now() + 1e3;
            this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
        }
        this.manager.globalRemaining--;
        const method = options.method ?? "get";
        const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
        if (res === null) {
            return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        const status = res.status;
        let retryAfter = 0;
        const limit = res.headers.get("X-RateLimit-Limit");
        const remaining = res.headers.get("X-RateLimit-Remaining");
        const reset = res.headers.get("X-RateLimit-Reset-After");
        const hash = res.headers.get("X-RateLimit-Bucket");
        const retry = res.headers.get("Retry-After");
        const scope = res.headers.get("X-RateLimit-Scope") ?? "user";
        const offset = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
        this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
        this.remaining = remaining ? Number(remaining) : 1;
        this.reset = reset ? Number(reset) * 1e3 + Date.now() + offset : Date.now();
        if (retry) retryAfter = Number(retry) * 1e3 + offset;
        if (hash && hash !== this.hash) {
            this.debug([
                "Received bucket hash update",
                `  Old Hash  : ${this.hash}`,
                `  New Hash  : ${hash}`
            ].join("\n"));
            this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, {
                value: hash,
                lastAccess: Date.now()
            });
        } else if (hash) {
            const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
            if (hashData) {
                hashData.lastAccess = Date.now();
            }
        }
        let sublimitTimeout = null;
        if (retryAfter > 0) {
            if (res.headers.has("X-RateLimit-Global")) {
                this.manager.globalRemaining = 0;
                this.manager.globalReset = Date.now() + retryAfter;
            } else if (!this.localLimited) {
                sublimitTimeout = retryAfter;
            }
        }
        if (status === 401 || status === 403 || status === 429) {
            incrementInvalidCount(this.manager);
        }
        if (res.ok) {
            return res;
        } else if (status === 429) {
            const isGlobal = this.globalLimited;
            let limit2;
            let timeout;
            if (isGlobal) {
                const offset2 = normalizeRateLimitOffset(this.manager.options.offset, routeId.bucketRoute);
                limit2 = this.manager.options.globalRequestsPerSecond;
                timeout = this.manager.globalReset + offset2 - Date.now();
            } else {
                limit2 = this.limit;
                timeout = this.getTimeToReset(routeId);
            }
            await onRateLimit(this.manager, {
                global: isGlobal,
                method,
                url,
                route: routeId.bucketRoute,
                majorParameter: this.majorParameter,
                hash: this.hash,
                limit: limit2,
                timeToReset: timeout,
                retryAfter,
                sublimitTimeout: sublimitTimeout ?? 0,
                scope
            });
            this.debug([
                "Encountered unexpected 429 rate limit",
                `  Global         : ${isGlobal.toString()}`,
                `  Method         : ${method}`,
                `  URL            : ${url}`,
                `  Bucket         : ${routeId.bucketRoute}`,
                `  Major parameter: ${routeId.majorParameter}`,
                `  Hash           : ${this.hash}`,
                `  Limit          : ${limit2}`,
                `  Retry After    : ${retryAfter}ms`,
                `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`,
                `  Scope          : ${scope}`
            ].join("\n"));
            if (sublimitTimeout) {
                const firstSublimit = !this.#sublimitedQueue;
                if (firstSublimit) {
                    this.#sublimitedQueue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sapphire$2f$async$2d$queue$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncQueue"]();
                    void this.#sublimitedQueue.wait();
                    this.#asyncQueue.shift();
                }
                this.#sublimitPromise?.resolve();
                this.#sublimitPromise = null;
                await sleep(sublimitTimeout);
                let resolve;
                const promise = new Promise((res2)=>resolve = res2);
                this.#sublimitPromise = {
                    promise,
                    resolve
                };
                if (firstSublimit) {
                    await this.#asyncQueue.wait();
                    this.#shiftSublimit = true;
                }
            }
            return this.runRequest(routeId, url, options, requestData, retries);
        } else {
            const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
            if (handled === null) {
                return this.runRequest(routeId, url, options, requestData, ++retries);
            }
            return handled;
        }
    }
};
// src/lib/REST.ts
var REST = class _REST extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$vladfrangu$2f$async_event_emitter$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AsyncEventEmitter"] {
    static{
        __name(this, "REST");
    }
    /**
   * The {@link https://undici.nodejs.org/#/docs/api/Agent | Agent} for all requests
   * performed by this manager.
   */ agent = null;
    cdn;
    /**
   * The number of requests remaining in the global bucket
   */ globalRemaining;
    /**
   * The promise used to wait out the global rate limit
   */ globalDelay = null;
    /**
   * The timestamp at which the global bucket resets
   */ globalReset = -1;
    /**
   * API bucket hashes that are cached from provided routes
   */ hashes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f40$discordjs$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Collection"]();
    /**
   * Request handlers created from the bucket hash and the major parameters
   */ handlers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f40$discordjs$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Collection"]();
    #token = null;
    hashTimer;
    handlerTimer;
    options;
    constructor(options = {}){
        super();
        this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn, options.mediaProxy ?? DefaultRestOptions.mediaProxy);
        this.options = {
            ...DefaultRestOptions,
            ...options
        };
        this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
        this.agent = options.agent ?? null;
        this.setupSweepers();
    }
    setupSweepers() {
        const validateMaxInterval = /* @__PURE__ */ __name((interval)=>{
            if (interval > 144e5) {
                throw new Error("Cannot set an interval greater than 4 hours");
            }
        }, "validateMaxInterval");
        if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
            validateMaxInterval(this.options.hashSweepInterval);
            this.hashTimer = setInterval(()=>{
                const sweptHashes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f40$discordjs$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Collection"]();
                const currentDate = Date.now();
                this.hashes.sweep((val, key)=>{
                    if (val.lastAccess === -1) return false;
                    const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
                    if (shouldSweep) {
                        sweptHashes.set(key, val);
                        this.emit("restDebug" /* Debug */ , `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
                    }
                    return shouldSweep;
                });
                this.emit("hashSweep" /* HashSweep */ , sweptHashes);
            }, this.options.hashSweepInterval);
            this.hashTimer.unref?.();
        }
        if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
            validateMaxInterval(this.options.handlerSweepInterval);
            this.handlerTimer = setInterval(()=>{
                const sweptHandlers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f40$discordjs$2f$collection$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Collection"]();
                this.handlers.sweep((val, key)=>{
                    const { inactive } = val;
                    if (inactive) {
                        sweptHandlers.set(key, val);
                        this.emit("restDebug" /* Debug */ , `Handler ${val.id} for ${key} swept due to being inactive`);
                    }
                    return inactive;
                });
                this.emit("handlerSweep" /* HandlerSweep */ , sweptHandlers);
            }, this.options.handlerSweepInterval);
            this.handlerTimer.unref?.();
        }
    }
    /**
   * Runs a get request from the api
   *
   * @param fullRoute - The full route to query
   * @param options - Optional request options
   */ async get(fullRoute, options = {}) {
        return this.request({
            ...options,
            fullRoute,
            method: "GET" /* Get */ 
        });
    }
    /**
   * Runs a delete request from the api
   *
   * @param fullRoute - The full route to query
   * @param options - Optional request options
   */ async delete(fullRoute, options = {}) {
        return this.request({
            ...options,
            fullRoute,
            method: "DELETE" /* Delete */ 
        });
    }
    /**
   * Runs a post request from the api
   *
   * @param fullRoute - The full route to query
   * @param options - Optional request options
   */ async post(fullRoute, options = {}) {
        return this.request({
            ...options,
            fullRoute,
            method: "POST" /* Post */ 
        });
    }
    /**
   * Runs a put request from the api
   *
   * @param fullRoute - The full route to query
   * @param options - Optional request options
   */ async put(fullRoute, options = {}) {
        return this.request({
            ...options,
            fullRoute,
            method: "PUT" /* Put */ 
        });
    }
    /**
   * Runs a patch request from the api
   *
   * @param fullRoute - The full route to query
   * @param options - Optional request options
   */ async patch(fullRoute, options = {}) {
        return this.request({
            ...options,
            fullRoute,
            method: "PATCH" /* Patch */ 
        });
    }
    /**
   * Runs a request from the api
   *
   * @param options - Request options
   */ async request(options) {
        const response = await this.queueRequest(options);
        return parseResponse(response);
    }
    /**
   * Sets the default agent to use for requests performed by this manager
   *
   * @param agent - The agent to use
   */ setAgent(agent) {
        this.agent = agent;
        return this;
    }
    /**
   * Sets the authorization token that should be used for requests
   *
   * @param token - The authorization token to use
   */ setToken(token) {
        this.#token = token;
        return this;
    }
    /**
   * Queues a request to be sent
   *
   * @param request - All the information needed to make a request
   * @returns The response from the api request
   */ async queueRequest(request2) {
        const routeId = _REST.generateRouteData(request2.fullRoute, request2.method);
        const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
            value: `Global(${request2.method}:${routeId.bucketRoute})`,
            lastAccess: -1
        };
        const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
        const { url, fetchOptions } = await this.resolveRequest(request2);
        return handler.queueRequest(routeId, url, fetchOptions, {
            body: request2.body,
            files: request2.files,
            auth: request2.auth !== false,
            signal: request2.signal
        });
    }
    /**
   * Creates a new rate limit handler from a hash, based on the hash and the major parameter
   *
   * @param hash - The hash for the route
   * @param majorParameter - The major parameter for this handler
   * @internal
   */ createHandler(hash, majorParameter) {
        const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
        this.handlers.set(queue.id, queue);
        return queue;
    }
    /**
   * Formats the request data to a usable format for fetch
   *
   * @param request - The request data
   */ async resolveRequest(request2) {
        const { options } = this;
        let query = "";
        if (request2.query) {
            const resolvedQuery = request2.query.toString();
            if (resolvedQuery !== "") {
                query = `?${resolvedQuery}`;
            }
        }
        const headers = {
            ...this.options.headers,
            "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
        };
        if (request2.auth !== false) {
            if (!this.#token) {
                throw new Error("Expected token to be set for this request, but none was present");
            }
            headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
        }
        if (request2.reason?.length) {
            headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
        }
        const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
        let finalBody;
        let additionalHeaders = {};
        if (request2.files?.length) {
            const formData = new FormData();
            for (const [index, file] of request2.files.entries()){
                const fileKey = file.key ?? `files[${index}]`;
                if (isBufferLike(file.data)) {
                    let contentType = file.contentType;
                    if (!contentType) {
                        const [parsedType] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$magic$2d$bytes$2e$js$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["filetypeinfo"])(file.data);
                        if (parsedType) {
                            contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
                        }
                    }
                    formData.append(fileKey, new Blob([
                        file.data
                    ], {
                        type: contentType
                    }), file.name);
                } else {
                    formData.append(fileKey, new Blob([
                        `${file.data}`
                    ], {
                        type: file.contentType
                    }), file.name);
                }
            }
            if (request2.body != null) {
                if (request2.appendToFormData) {
                    for (const [key, value] of Object.entries(request2.body)){
                        formData.append(key, value);
                    }
                } else {
                    formData.append("payload_json", JSON.stringify(request2.body));
                }
            }
            finalBody = formData;
        } else if (request2.body != null) {
            if (request2.passThroughBody) {
                finalBody = request2.body;
            } else {
                finalBody = JSON.stringify(request2.body);
                additionalHeaders = {
                    "Content-Type": "application/json"
                };
            }
        }
        const method = request2.method.toUpperCase();
        const fetchOptions = {
            // Set body to null on get / head requests. This does not follow fetch spec (likely because it causes subtle bugs) but is aligned with what request was doing
            body: [
                "GET",
                "HEAD"
            ].includes(method) ? null : finalBody,
            headers: {
                ...request2.headers,
                ...additionalHeaders,
                ...headers
            },
            method,
            // Prioritize setting an agent per request, use the agent for this instance otherwise.
            dispatcher: request2.dispatcher ?? this.agent ?? void 0
        };
        return {
            url,
            fetchOptions
        };
    }
    /**
   * Stops the hash sweeping interval
   */ clearHashSweeper() {
        clearInterval(this.hashTimer);
    }
    /**
   * Stops the request handler sweeping interval
   */ clearHandlerSweeper() {
        clearInterval(this.handlerTimer);
    }
    /**
   * Generates route data for an endpoint:method
   *
   * @param endpoint - The raw endpoint to generalize
   * @param method - The HTTP method this endpoint is called without
   * @internal
   */ static generateRouteData(endpoint, method) {
        if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
            return {
                majorParameter: BurstHandlerMajorIdKey,
                bucketRoute: "/interactions/:id/:token/callback",
                original: endpoint
            };
        }
        const majorIdMatch = /(?:^\/webhooks\/(\d{17,19}\/[^/?]+))|(?:^\/(?:channels|guilds|webhooks)\/(\d{17,19}))/.exec(endpoint);
        const majorId = majorIdMatch?.[2] ?? majorIdMatch?.[1] ?? "global";
        const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction").replace(/\/webhooks\/:id\/[^/?]+/, "/webhooks/:id/:token");
        let exceptions = "";
        if (method === "DELETE" /* Delete */  && baseRoute === "/channels/:id/messages/:id") {
            const id = /\d{17,19}$/.exec(endpoint)[0];
            const timestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$sapphire$2f$snowflake$2f$dist$2f$esm$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DiscordSnowflake"].timestampFrom(id);
            if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
                exceptions += "/Delete Old Message";
            }
        }
        return {
            majorParameter: majorId,
            bucketRoute: baseRoute + exceptions,
            original: endpoint
        };
    }
};
// src/shared.ts
var version = "2.6.0";
// src/index.ts
globalThis.FormData ??= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$rest$2f$node_modules$2f$undici$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FormData"];
globalThis.Blob ??= __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$buffer__$5b$external$5d$__$28$node$3a$buffer$2c$__cjs$29$__["Blob"];
setDefaultStrategy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$discordjs$2f$util$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["shouldUseGlobalFetchAndWebSocket"])() ? fetch : makeRequest);
;
 //# sourceMappingURL=index.mjs.map
}),

};

//# sourceMappingURL=node_modules_6db9aafe._.js.map